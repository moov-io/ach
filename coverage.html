
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com\bkmoovio\ach\addenda02.go (100.0%)</option>
				
				<option value="file1">github.com\bkmoovio\ach\addenda05.go (100.0%)</option>
				
				<option value="file2">github.com\bkmoovio\ach\addenda98.go (100.0%)</option>
				
				<option value="file3">github.com\bkmoovio\ach\addenda99.go (93.8%)</option>
				
				<option value="file4">github.com\bkmoovio\ach\batch.go (96.7%)</option>
				
				<option value="file5">github.com\bkmoovio\ach\batchARC.go (100.0%)</option>
				
				<option value="file6">github.com\bkmoovio\ach\batchBOC.go (100.0%)</option>
				
				<option value="file7">github.com\bkmoovio\ach\batchCCD.go (100.0%)</option>
				
				<option value="file8">github.com\bkmoovio\ach\batchCOR.go (90.9%)</option>
				
				<option value="file9">github.com\bkmoovio\ach\batchControl.go (100.0%)</option>
				
				<option value="file10">github.com\bkmoovio\ach\batchHeader.go (100.0%)</option>
				
				<option value="file11">github.com\bkmoovio\ach\batchPOP.go (100.0%)</option>
				
				<option value="file12">github.com\bkmoovio\ach\batchPOS.go (100.0%)</option>
				
				<option value="file13">github.com\bkmoovio\ach\batchPPD.go (92.9%)</option>
				
				<option value="file14">github.com\bkmoovio\ach\batchRCK.go (96.8%)</option>
				
				<option value="file15">github.com\bkmoovio\ach\batchTEL.go (100.0%)</option>
				
				<option value="file16">github.com\bkmoovio\ach\batchWeb.go (100.0%)</option>
				
				<option value="file17">github.com\bkmoovio\ach\batcher.go (100.0%)</option>
				
				<option value="file18">github.com\bkmoovio\ach\converters.go (100.0%)</option>
				
				<option value="file19">github.com\bkmoovio\ach\entryDetail.go (96.2%)</option>
				
				<option value="file20">github.com\bkmoovio\ach\file.go (100.0%)</option>
				
				<option value="file21">github.com\bkmoovio\ach\fileControl.go (100.0%)</option>
				
				<option value="file22">github.com\bkmoovio\ach\fileHeader.go (100.0%)</option>
				
				<option value="file23">github.com\bkmoovio\ach\reader.go (96.9%)</option>
				
				<option value="file24">github.com\bkmoovio\ach\validators.go (100.0%)</option>
				
				<option value="file25">github.com\bkmoovio\ach\writer.go (70.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "fmt"
        "strings"
)

// Addenda02 is a Addendumer addenda which provides business transaction information for Addenda Type
// Code 02 in a machine readable format. It is usually formatted according to ANSI, ASC, X12 Standard.
type Addenda02 struct {
        //ToDo: Verify which fields should be omitempty
        //ToDo: Add mor descriptive comments
        // ID is a client defined string used as a reference to this record.
        ID string `json:"id"`
        // RecordType defines the type of record in the block. entryAddenda02 Pos 7
        recordType string
        // TypeCode Addenda02 types code '02'
        typeCode string
        // ReferenceInformationOne
        ReferenceInformationOne string `json:"referenceInformationOne"`
        // ReferenceInformationTwo
        ReferenceInformationTwo string `json:"referenceInformationTwo"`
        // TerminalIdentificationCode
        TerminalIdentificationCode string `json:"terminalIdentificationCode"`
        // TransactionSerialNumber
        TransactionSerialNumber string `json:"transactionSerialNumber"`
        // TransactionDate MMDD
        TransactionDate string `json:"transactionDate"`
        // TraceNumber matches the Entry Detail Trace Number of the entry being returned.
        // AuthorizationCodeOrExpireDate
        AuthorizationCodeOrExpireDate string `json:"authorizationCodeOrExpireDate"`
        // Terminal Location
        TerminalLocation string `json:"terminalLocation"`
        // TerminalCity
        TerminalCity string `json:"terminalCity"`
        // TerminalState
        TerminalState string `json:"terminalState"`
        // TraceNumber matches the Entry Detail Trace Number of the entry being returned.
        TraceNumber int `json:"traceNumber,omitempty"`
        // validator is composed for data validation
        validator
        // converters is composed for ACH to GoLang Converters
        converters
}

// NewAddenda02 returns a new Addenda02 with default values for none exported fields
func NewAddenda02() *Addenda02 <span class="cov8" title="1">{
        addenda02 := new(Addenda02)
        addenda02.recordType = "7"
        addenda02.typeCode = "02"
        return addenda02
}</span>

// Parse takes the input record string and parses the Addenda02 values
func (addenda02 *Addenda02) Parse(record string) <span class="cov8" title="1">{
        // 1-1 Always "7"
        addenda02.recordType = "7"
        // 2-3 Always 02
        addenda02.typeCode = record[1:3]
        // 4-10 Based on the information entered (04-10) 7 alphanumeric
        addenda02.ReferenceInformationOne = strings.TrimSpace(record[3:10])
        // 11-13 Based on the information entered (11-13) 3 alphanumeric
        addenda02.ReferenceInformationTwo = strings.TrimSpace(record[10:13])
        // 14-19
        addenda02.TerminalIdentificationCode = strings.TrimSpace(record[13:19])
        // 20-25
        addenda02.TransactionSerialNumber = strings.TrimSpace(record[19:25])
        // 26-29
        addenda02.TransactionDate = strings.TrimSpace(record[25:29])
        // 30-35
        addenda02.AuthorizationCodeOrExpireDate = strings.TrimSpace(record[29:35])
        // 36-62
        addenda02.TerminalLocation = strings.TrimSpace(record[35:62])
        // 63-77
        addenda02.TerminalCity = strings.TrimSpace(record[62:77])
        // 78-79
        addenda02.TerminalState = strings.TrimSpace(record[77:79])
        // 80-94
        addenda02.TraceNumber = addenda02.parseNumField(record[79:94])
}</span>

// String writes the Addenda02 struct to a 94 character string.
func (addenda02 *Addenda02) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v",
                addenda02.recordType,
                addenda02.typeCode,
                addenda02.ReferenceInformationOneField(),
                addenda02.ReferenceInformationTwoField(),
                addenda02.TerminalIdentificationCodeField(),
                addenda02.TransactionSerialNumberField(),
                // ToDo: Follow up on best way to get TransactionDate - should it be treated as an alpha field
                addenda02.TransactionDateField(),
                addenda02.AuthorizationCodeOrExpireDateField(),
                addenda02.TerminalLocationField(),
                addenda02.TerminalCityField(),
                addenda02.TerminalStateField(),
                addenda02.TraceNumberField(),
        )
}</span>

// Validate performs NACHA format rule checks on the record and returns an error if not Validated
// The first error encountered is returned and stops that parsing.
func (addenda02 *Addenda02) Validate() error <span class="cov8" title="1">{
        if err := addenda02.fieldInclusion(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if addenda02.recordType != "7" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgRecordType, 7)
                return &amp;FieldError{FieldName: "recordType", Value: addenda02.recordType, Msg: msg}
        }</span>
        <span class="cov8" title="1">if err := addenda02.isTypeCode(addenda02.typeCode); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TypeCode", Value: addenda02.typeCode, Msg: err.Error()}
        }</span>
        // Type Code must be 02
        // ToDo: Evaluate if Addenda05 and Addenda99 should be modified to validate on 05 and 99
        <span class="cov8" title="1">if addenda02.typeCode != "02" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TypeCode", Value: addenda02.typeCode, Msg: msgAddendaTypeCode}
        }</span>
        // ToDo: Validation for TransactionDate MMDD
        <span class="cov8" title="1">return nil</span>
}

// fieldInclusion validate mandatory fields are not default values. If fields are
// invalid the ACH transfer will be returned.

// ToDo: check if we should do fieldInclusion or validate on required fields

func (addenda02 *Addenda02) fieldInclusion() error <span class="cov8" title="1">{
        if addenda02.recordType == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "recordType", Value: addenda02.recordType, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if addenda02.typeCode == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TypeCode", Value: addenda02.typeCode, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if addenda02.TerminalIdentificationCode == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TerminalIdentificationCode", Value: addenda02.TerminalIdentificationCode, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if addenda02.TransactionSerialNumber == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TransactionSerialNumber", Value: addenda02.TransactionSerialNumber, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if addenda02.TransactionDate == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TransactionDate", Value: addenda02.TransactionDate, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if addenda02.TerminalLocation == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TerminalLocation", Value: addenda02.TerminalLocation, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if addenda02.TerminalCity == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TerminalCity", Value: addenda02.TerminalCity, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if addenda02.TerminalState == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TerminalState", Value: addenda02.TerminalState, Msg: msgFieldInclusion}
        }</span>
        // ToDo: Determine if TraceNumber fieldInclusion is necessary
        <span class="cov8" title="1">return nil</span>
}

// TypeCode Defines the specific explanation and format for the addenda02 information
func (addenda02 *Addenda02) TypeCode() string <span class="cov8" title="1">{
        return addenda02.typeCode
}</span>

// ReferenceInformationOneField returns a space padded ReferenceInformationOne string
func (addenda02 *Addenda02) ReferenceInformationOneField() string <span class="cov8" title="1">{
        return addenda02.alphaField(addenda02.ReferenceInformationOne, 7)
}</span>

// ReferenceInformationTwoField returns a space padded ReferenceInformationTwo string
func (addenda02 *Addenda02) ReferenceInformationTwoField() string <span class="cov8" title="1">{
        return addenda02.alphaField(addenda02.ReferenceInformationOne, 3)
}</span>

// TerminalIdentificationCodeField returns a space padded TerminalIdentificationCode string
func (addenda02 *Addenda02) TerminalIdentificationCodeField() string <span class="cov8" title="1">{
        return addenda02.alphaField(addenda02.TerminalIdentificationCode, 6)
}</span>

// TransactionSerialNumberField returns a zero padded TransactionSerialNumber string
func (addenda02 *Addenda02) TransactionSerialNumberField() string <span class="cov8" title="1">{
        return addenda02.alphaField(addenda02.TransactionSerialNumber, 6)
}</span>

// TransactionDateField returns TransactionDate MMDD string
func (addenda02 *Addenda02) TransactionDateField() string <span class="cov8" title="1">{
        //ToDo: see about padding
        return addenda02.TransactionDate
}</span>

// AuthorizationCodeOrExpireDateField returns a space padded AuthorizationCodeOrExpireDate string
func (addenda02 *Addenda02) AuthorizationCodeOrExpireDateField() string <span class="cov8" title="1">{
        return addenda02.alphaField(addenda02.AuthorizationCodeOrExpireDate, 6)
}</span>

//TerminalLocationField returns a space padded TerminalLocation string
func (addenda02 *Addenda02) TerminalLocationField() string <span class="cov8" title="1">{
        return addenda02.alphaField(addenda02.TerminalLocation, 27)
}</span>

//TerminalCityField returns a space padded TerminalCity string
func (addenda02 *Addenda02) TerminalCityField() string <span class="cov8" title="1">{
        return addenda02.alphaField(addenda02.TerminalCity, 15)
}</span>

//TerminalStateField returns a space padded TerminalState string
func (addenda02 *Addenda02) TerminalStateField() string <span class="cov8" title="1">{
        return addenda02.alphaField(addenda02.TerminalState, 2)
}</span>

// TraceNumberField returns a space padded traceNumber string
func (addenda02 *Addenda02) TraceNumberField() string <span class="cov8" title="1">{
        return addenda02.numericField(addenda02.TraceNumber, 15)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "fmt"
        "strings"
)

// Addenda05 is a Addendumer addenda which provides business transaction information for Addenda Type
// Code 05 in a machine readable format. It is usually formatted according to ANSI, ASC, X12 Standard.
type Addenda05 struct {
        // ID is a client defined string used as a reference to this record.
        ID string `json:"id"`
        // RecordType defines the type of record in the block. entryAddenda05 Pos 7
        recordType string
        // TypeCode Addenda05 types code '05'
        typeCode string
        // PaymentRelatedInformation
        PaymentRelatedInformation string `json:"paymentRelatedInformation"`
        // SequenceNumber is consecutively assigned to each Addenda05 Record following
        // an Entry Detail Record. The first addenda05 sequence number must always
        // be a "1".
        SequenceNumber int `json:"sequenceNumber,omitempty"`
        // EntryDetailSequenceNumber contains the ascending sequence number section of the Entry
        // Detail or Corporate Entry Detail Record's trace number This number is
        // the same as the last seven digits of the trace number of the related
        // Entry Detail Record or Corporate Entry Detail Record.
        EntryDetailSequenceNumber int `json:"entryDetailSequenceNumber,omitempty"`
        // validator is composed for data validation
        validator
        // converters is composed for ACH to GoLang Converters
        converters
}

// NewAddenda05 returns a new Addenda05 with default values for none exported fields
func NewAddenda05() *Addenda05 <span class="cov8" title="1">{
        addenda05 := new(Addenda05)
        addenda05.recordType = "7"
        addenda05.typeCode = "05"
        return addenda05
}</span>

// Parse takes the input record string and parses the Addenda05 values
func (addenda05 *Addenda05) Parse(record string) <span class="cov8" title="1">{
        // 1-1 Always "7"
        addenda05.recordType = "7"
        // 2-3 Always 05
        addenda05.typeCode = record[1:3]
        // 4-83 Based on the information entered (04-83) 80 alphanumeric
        addenda05.PaymentRelatedInformation = strings.TrimSpace(record[3:83])
        // 84-87 SequenceNumber is consecutively assigned to each Addenda05 Record following
        // an Entry Detail Record
        addenda05.SequenceNumber = addenda05.parseNumField(record[83:87])
        // 88-94 Contains the last seven digits of the number entered in the Trace Number field in the corresponding Entry Detail Record
        addenda05.EntryDetailSequenceNumber = addenda05.parseNumField(record[87:94])
}</span>

// String writes the Addenda05 struct to a 94 character string.
func (addenda05 *Addenda05) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v%v%v%v%v",
                addenda05.recordType,
                addenda05.typeCode,
                addenda05.PaymentRelatedInformationField(),
                addenda05.SequenceNumberField(),
                addenda05.EntryDetailSequenceNumberField())
}</span>

// Validate performs NACHA format rule checks on the record and returns an error if not Validated
// The first error encountered is returned and stops that parsing.
func (addenda05 *Addenda05) Validate() error <span class="cov8" title="1">{
        if err := addenda05.fieldInclusion(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if addenda05.recordType != "7" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgRecordType, 7)
                return &amp;FieldError{FieldName: "recordType", Value: addenda05.recordType, Msg: msg}
        }</span>
        <span class="cov8" title="1">if err := addenda05.isTypeCode(addenda05.typeCode); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TypeCode", Value: addenda05.typeCode, Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if err := addenda05.isAlphanumeric(addenda05.PaymentRelatedInformation); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "PaymentRelatedInformation", Value: addenda05.PaymentRelatedInformation, Msg: err.Error()}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// fieldInclusion validate mandatory fields are not default values. If fields are
// invalid the ACH transfer will be returned.
func (addenda05 *Addenda05) fieldInclusion() error <span class="cov8" title="1">{
        if addenda05.recordType == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "recordType", Value: addenda05.recordType, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if addenda05.typeCode == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TypeCode", Value: addenda05.typeCode, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if addenda05.SequenceNumber == 0 </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "SequenceNumber", Value: addenda05.SequenceNumberField(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if addenda05.EntryDetailSequenceNumber == 0 </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "EntryDetailSequenceNumber", Value: addenda05.EntryDetailSequenceNumberField(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// PaymentRelatedInformationField returns a zero padded PaymentRelatedInformation string
func (addenda05 *Addenda05) PaymentRelatedInformationField() string <span class="cov8" title="1">{
        return addenda05.alphaField(addenda05.PaymentRelatedInformation, 80)
}</span>

// SequenceNumberField returns a zero padded SequenceNumber string
func (addenda05 *Addenda05) SequenceNumberField() string <span class="cov8" title="1">{
        return addenda05.numericField(addenda05.SequenceNumber, 4)
}</span>

// EntryDetailSequenceNumberField returns a zero padded EntryDetailSequenceNumber string
func (addenda05 *Addenda05) EntryDetailSequenceNumberField() string <span class="cov8" title="1">{
        return addenda05.numericField(addenda05.EntryDetailSequenceNumber, 7)
}</span>

// TypeCode Defines the specific explanation and format for the addenda05 information
func (addenda05 *Addenda05) TypeCode() string <span class="cov8" title="1">{
        return addenda05.typeCode
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "fmt"
        "strings"
)

// Addenda98 is a Addendumer addenda record format for Notification OF Change(98)
// The field contents for Notification of Change Entries must match the field contents of the original Entries
type Addenda98 struct {
        // ID is a client defined string used as a reference to this record.
        ID string `json:"id"`
        // RecordType defines the type of record in the block. entryAddendaPos 7
        recordType string
        // TypeCode Addenda types code '98'
        typeCode string
        // ChangeCode field contains a standard code used by an ACH Operator or RDFI to describe the reason for a change Entry.
        // Must exist in changeCodeDict
        ChangeCode string `json:"changeCode"`
        // OriginalTrace This field contains the Trace Number as originally included on the forward Entry or Prenotification.
        // The RDFI must include the Original Entry Trace Number in the Addenda Record of an Entry being returned to an ODFI,
        // in the Addenda Record of an 98, within an Acknowledgment Entry, or with an RDFI request for a copy of an authorization.
        OriginalTrace int `json:"originalTrace"`
        // OriginalDFI field contains the Receiving DFI Identification (addenda.RDFIIdentification) as originally included on the forward Entry or Prenotification that the RDFI is returning or correcting.
        OriginalDFI string `json:"originalDFI"`
        // CorrectedData
        CorrectedData string `json:"correctedData"`
        // TraceNumber matches the Entry Detail Trace Number of the entry being returned.
        TraceNumber int `json:"traceNumber,omitempty"`

        // validator is composed for data validation
        validator
        // converters is composed for ACH to GoLang Converters
        converters
}

var (
        changeCodeDict = map[string]*changeCode{}

        // Error messages specific to Addenda98
        msgAddenda98ChangeCode    = "found is not a valid addenda Change Code"
        msgAddenda98CorrectedData = "must contain the corrected information corresponding to the Change Code"
)

func init() <span class="cov8" title="1">{
        // populate the changeCode map with lookup values
        changeCodeDict = makeChangeCodeDict()
}</span>

// changeCode holds a change Code, Reason/Title, and Description
// table of return codes exists in Part 4.2 of the NACHA corporate rules and guidelines
type changeCode struct {
        Code, Reason, Description string
}

// NewAddenda98 returns an reference to an instantiated Addenda98 with default values
func NewAddenda98() *Addenda98 <span class="cov8" title="1">{
        addenda98 := &amp;Addenda98{
                recordType: "7",
                typeCode:   "98",
        }
        return addenda98
}</span>

// Parse takes the input record string and parses the Addenda98 values
func (addenda98 *Addenda98) Parse(record string) <span class="cov8" title="1">{
        // 1-1 Always "7"
        addenda98.recordType = "7"
        // 2-3 Always "98"
        addenda98.typeCode = record[1:3]
        // 4-6
        addenda98.ChangeCode = record[3:6]
        // 7-21
        addenda98.OriginalTrace = addenda98.parseNumField(record[6:21])
        // 28-35
        addenda98.OriginalDFI = addenda98.parseStringField(record[27:35])
        // 36-64
        addenda98.CorrectedData = strings.TrimSpace(record[35:64])
        // 80-94
        addenda98.TraceNumber = addenda98.parseNumField(record[79:94])
}</span>

// String writes the Addenda98 struct to a 94 character string
func (addenda98 *Addenda98) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v%v%v%v%v%v%v%v%v",
                addenda98.recordType,
                addenda98.TypeCode(),
                addenda98.ChangeCode,
                addenda98.OriginalTraceField(),
                "      ", //6 char reserved field
                addenda98.OriginalDFIField(),
                addenda98.CorrectedDataField(),
                "               ", // 15 char reserved field
                addenda98.TraceNumberField(),
        )
}</span>

// Validate verifies NACHA rules for Addenda98
func (addenda98 *Addenda98) Validate() error <span class="cov8" title="1">{
        if addenda98.recordType != "7" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgRecordType, 7)
                return &amp;FieldError{FieldName: "recordType", Value: addenda98.recordType, Msg: msg}
        }</span>
        // Type Code must be 98
        <span class="cov8" title="1">if addenda98.typeCode != "98" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TypeCode", Value: addenda98.typeCode, Msg: msgAddendaTypeCode}
        }</span>

        // Addenda98 requires a valid ChangeCode
        <span class="cov8" title="1">_, ok := changeCodeDict[addenda98.ChangeCode]
        if !ok </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ChangeCode", Value: addenda98.ChangeCode, Msg: msgAddenda98ChangeCode}
        }</span>

        // Addenda98 Record must contain the corrected information corresponding to the Change Code used
        <span class="cov8" title="1">if addenda98.CorrectedData == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "CorrectedData", Value: addenda98.CorrectedData, Msg: msgAddenda98CorrectedData}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// TypeCode defines the format of the underlying addenda record
func (addenda98 *Addenda98) TypeCode() string <span class="cov8" title="1">{
        return addenda98.typeCode
}</span>

// OriginalTraceField returns a zero padded OriginalTrace string
func (addenda98 *Addenda98) OriginalTraceField() string <span class="cov8" title="1">{
        return addenda98.numericField(addenda98.OriginalTrace, 15)
}</span>

// OriginalDFIField returns a zero padded OriginalDFI string
func (addenda98 *Addenda98) OriginalDFIField() string <span class="cov8" title="1">{
        return addenda98.stringRTNField(addenda98.OriginalDFI, 8)
}</span>

//CorrectedDataField returns a space padded CorrectedData string
func (addenda98 *Addenda98) CorrectedDataField() string <span class="cov8" title="1">{
        return addenda98.alphaField(addenda98.CorrectedData, 29)
}</span>

// TraceNumberField returns a zero padded traceNumber string
func (addenda98 *Addenda98) TraceNumberField() string <span class="cov8" title="1">{
        return addenda98.numericField(addenda98.TraceNumber, 15)
}</span>

func makeChangeCodeDict() map[string]*changeCode <span class="cov8" title="1">{
        dict := make(map[string]*changeCode)

        codes := []changeCode{
                {"C01", "Incorrect bank account number", "Bank account number incorrect or formatted incorrectly"},
                {"C02", "Incorrect transit/routing number", "Once valid transit/routing number must be changed"},
                {"C03", "Incorrect transit/routing number and bank account number", "Once valid transit/routing number must be changed and causes a change to bank account number structure"},
                {"C04", "Bank account name change", "Customer has changed name or ODFI submitted name incorrectly"},
                {"C05", "Incorrect payment code", "Entry posted to demand account should contain savings payment codes or vice versa"},
                {"C06", "Incorrect bank account number and transit code", "Bank account number must be changed and payment code should indicate posting to another account type (demand/savings)"},
                {"C07", "Incorrect transit/routing number, bank account number and payment code", "Changes required in three fields indicated"},
                {"C09", "Incorrect individual ID number", "Individual's ID number is incorrect"},
                {"C10", "Incorrect company name", "Company name is no longer valid and should be changed."},
                {"C11", "Incorrect company identification", "Company ID is no longer valid and should be changed"},
                {"C12", "Incorrect company name and company ID", "Both the company name and company id are no longer valid and must be changed"},
        }
        // populate the map
        for _, code := range codes </span><span class="cov8" title="1">{
                dict[code.Code] = &amp;code
        }</span>
        <span class="cov8" title="1">return dict</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "fmt"
        "strings"
        "time"
)

// When a Return Entry is prepared, the original Company/Batch Header Record, the original Entry Detail Record,
// and the Company/Batch Control Record are copied for return to the Originator.
//
// The Return Entry is a new Entry. These Entries must be assigned new batch and trace numbers, new identification numbers for the returning institution,
// appropriate transaction codes, etc., as required per format specifications.
//
// See Appendix Four: Return Entries in the NACHA Corporate

var (
        returnCodeDict = map[string]*returnCode{}

        // Error messages specific to Return Addenda
        msgAddenda99ReturnCode = "found is not a valid return code"
)

func init() <span class="cov8" title="1">{
        // populate the returnCode map with lookup values
        returnCodeDict = makeReturnCodeDict()
}</span>

// Addenda99 utilized for Notification of Change Entry (COR) and Return types.
type Addenda99 struct {
        // ID is a client defined string used as a reference to this record.
        ID string `json:"id"`
        // RecordType defines the type of record in the block. entryAddendaPos 7
        recordType string
        // TypeCode Addenda types code '99'
        typeCode string
        // ReturnCode field contains a standard code used by an ACH Operator or RDFI to describe the reason for returning an Entry.
        // Must exist in returnCodeDict
        ReturnCode string `json:"returnCode"`
        // OriginalTrace This field contains the Trace Number as originally included on the forward Entry or Prenotification.
        // The RDFI must include the Original Entry Trace Number in the Addenda Record of an Entry being returned to an ODFI,
        // in the Addenda Record of an 98, within an Acknowledgment Entry, or with an RDFI request for a copy of an authorization.
        OriginalTrace int `json:"originalTrace"`
        // DateOfDeath The field date of death is to be supplied on Entries being returned for reason of death (return reason codes R14 and R15).
        DateOfDeath time.Time `json:"dateOfDeath"`
        // OriginalDFI field contains the Receiving DFI Identification (addenda.RDFIIdentification) as originally included on the forward Entry or Prenotification that the RDFI is returning or correcting.
        OriginalDFI string `json:"originalDFI"`
        // AddendaInformation
        AddendaInformation string `json:"addendaInformation,omitempty"`
        // TraceNumber matches the Entry Detail Trace Number of the entry being returned.
        TraceNumber int `json:"traceNumber,omitempty"`

        // validator is composed for data validation
        validator
        // converters is composed for ACH to GoLang Converters
        converters
}

// returnCode holds a return Code, Reason/Title, and Description
//
// Table of return codes exists in Part 4.2 of the NACHA corporate rules and guidelines
type returnCode struct {
        Code, Reason, Description string
}

// NewAddenda99 returns a new Addenda99 with default values for none exported fields
func NewAddenda99() *Addenda99 <span class="cov8" title="1">{
        Addenda99 := &amp;Addenda99{
                recordType: "7",
                typeCode:   "99",
        }
        return Addenda99
}</span>

// Parse takes the input record string and parses the Addenda99 values
func (Addenda99 *Addenda99) Parse(record string) <span class="cov8" title="1">{
        // 1-1 Always "7"
        Addenda99.recordType = "7"
        // 2-3 Defines the specific explanation and format for the addenda information contained in the same record
        Addenda99.typeCode = record[1:3]
        // 4-6
        Addenda99.ReturnCode = record[3:6]
        // 7-21
        Addenda99.OriginalTrace = Addenda99.parseNumField(record[6:21])
        // 22-27, might be a date or blank
        Addenda99.DateOfDeath = Addenda99.parseSimpleDate(record[21:27])
        // 28-35
        Addenda99.OriginalDFI = Addenda99.parseStringField(record[27:35])
        // 36-79
        Addenda99.AddendaInformation = strings.TrimSpace(record[35:79])
        // 80-94
        Addenda99.TraceNumber = Addenda99.parseNumField(record[79:94])
}</span>

// String writes the Addenda99 struct to a 94 character string
func (Addenda99 *Addenda99) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v%v%v%v%v%v%v%v",
                Addenda99.recordType,
                Addenda99.TypeCode(),
                Addenda99.ReturnCode,
                Addenda99.OriginalTraceField(),
                Addenda99.DateOfDeathField(),
                Addenda99.OriginalDFIField(),
                Addenda99.AddendaInformationField(),
                Addenda99.TraceNumberField(),
        )
}</span>

// Validate verifies NACHA rules for Addenda99
func (Addenda99 *Addenda99) Validate() error <span class="cov8" title="1">{

        if Addenda99.recordType != "7" </span><span class="cov0" title="0">{
                msg := fmt.Sprintf(msgRecordType, 7)
                return &amp;FieldError{FieldName: "recordType", Value: Addenda99.recordType, Msg: msg}
        }</span>
        // @TODO Type Code should be 99.

        <span class="cov8" title="1">_, ok := returnCodeDict[Addenda99.ReturnCode]
        if !ok </span><span class="cov8" title="1">{
                // Return Addenda requires a valid ReturnCode
                return &amp;FieldError{FieldName: "ReturnCode", Value: Addenda99.ReturnCode, Msg: msgAddenda99ReturnCode}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// TypeCode defines the format of the underlying addenda record
func (Addenda99 *Addenda99) TypeCode() string <span class="cov8" title="1">{
        return Addenda99.typeCode
}</span>

// OriginalTraceField returns a zero padded OriginalTrace string
func (Addenda99 *Addenda99) OriginalTraceField() string <span class="cov8" title="1">{
        return Addenda99.numericField(Addenda99.OriginalTrace, 15)
}</span>

// DateOfDeathField returns a space padded DateOfDeath string
func (Addenda99 *Addenda99) DateOfDeathField() string <span class="cov8" title="1">{
        // Return space padded 6 characters if it is a zero value of DateOfDeath
        if Addenda99.DateOfDeath.IsZero() </span><span class="cov8" title="1">{
                return Addenda99.alphaField("", 6)
        }</span>
        // YYMMDD
        <span class="cov8" title="1">return Addenda99.formatSimpleDate(Addenda99.DateOfDeath)</span>
}

// OriginalDFIField returns a zero padded OriginalDFI string
func (Addenda99 *Addenda99) OriginalDFIField() string <span class="cov8" title="1">{
        return Addenda99.stringRTNField(Addenda99.OriginalDFI, 8)
}</span>

//AddendaInformationField returns a space padded AddendaInformation string
func (Addenda99 *Addenda99) AddendaInformationField() string <span class="cov8" title="1">{
        return Addenda99.alphaField(Addenda99.AddendaInformation, 44)
}</span>

// TraceNumberField returns a zero padded traceNumber string
func (Addenda99 *Addenda99) TraceNumberField() string <span class="cov8" title="1">{
        return Addenda99.numericField(Addenda99.TraceNumber, 15)
}</span>

func makeReturnCodeDict() map[string]*returnCode <span class="cov8" title="1">{
        dict := make(map[string]*returnCode)

        codes := []returnCode{
                // Return Reason Codes for RDFIs
                {"R01", "Insufficient Funds", "Available balance is not sufficient to cover the dollar value of the debit entry"},
                {"R02", "Account Closed", "Previously active account has been closed by customer or RDFI"},
                // R03 may not be used to return ARC, BOC or POP entries solely because they do not contain an Individual Name.
                {"R03", "No Account/Unable to Locate Account", "Account number structure is valid and passes editing process, but does not correspond to individual or is not an open account"},
                {"R04", "Invalid Account Number", "Account number structure not valid; entry may fail check digit validation or may contain an incorrect number of digits."},
                {"R05", "Improper Debit to Consumer Account", "A CCD, CTX, or CBR debit entry was transmitted to a Consumer Account of the Receiver and was not authorized by the Receiver"},
                {"R06", "Returned per ODFI's Request", "ODFI has requested RDFI to return the ACH entry (optional to RDFI - ODFI indemnifies RDFI)}"},
                // R07 Prohibited use for ARC, BOC, POP and RCK.
                {"R07", "Authorization Revoked by Customer", "Consumer, who previously authorized ACH payment, has revoked authorization from Originator (must be returned no later than 60 days from settlement date and customer must sign affidavit)"},
                {"R08", "Payment Stopped", "Receiver of a recurring debit transaction has stopped payment to a specific ACH debit. RDFI should verify the Receiver's intent when a request for stop payment is made to insure this is not intended to be a revocation of authorization"},
                {"R09", "Uncollected Funds", "Sufficient book or ledger balance exists to satisfy dollar value of the transaction, but the dollar value of transaction is in process of collection (i.e., uncollected checks) or cash reserve balance below dollar value of the debit entry."},
                {"R10", "Customer Advises Not Authorized", "Consumer has advised RDFI that Originator of transaction is not authorized to debit account (must be returned no later than 60 days from settlement date of original entry and customer must sign affidavit)."},
                {"R11", "Check Truncation Entry Returned", "Used when returning a check safekeeping entry; RDFI should use appropriate field in addenda record to specify reason for return (i.e., 'exceeds dollar limit,' 'stale date,' etc.)."},
                {"R12", "Branch Sold to Another DFI", "Financial institution receives entry destined for an account at a branch that has been sold to another financial institution."},
                {"R13", "RDFI not qualified to participate", "Financial institution does not receive commercial ACH entries"},
                {"R14", "Representative payee deceased or unable to continue in that capacity", "The representative payee authorized to accept entries on behalf of a beneficiary is either deceased or unable to continue in that capacity"},
                {"R15", "Beneficiary or bank account holder", "(Other than representative payee) deceased* - (1) the beneficiary entitled to payments is deceased or (2) the bank account holder other than a representative payee is deceased"},
                {"R16", "Bank account frozen", "Funds in bank account are unavailable due to action by RDFI or legal order"},
                {"R17", "File record edit criteria", "Fields rejected by RDFI processing (identified in return addenda)"},
                {"R18", "Improper effective entry date", "Entries have been presented prior to the first available processing window for the effective date."},
                {"R19", "Amount field error", "Improper formatting of the amount field"},
                {"R20", "Non-payment bank account", "Entry destined for non-payment bank account defined by reg."},
                {"R21", "Invalid company ID number", "The company ID information not valid (normally CIE entries)"},
                {"R22", "Invalid individual ID number", "Individual id used by receiver is incorrect (CIE entries)"},
                {"R23", "Credit entry refused by receiver", "Receiver returned entry because minimum or exact amount not remitted, bank account is subject to litigation, or payment represents an overpayment, originator is not known to receiver or receiver has not authorized this credit entry to this bank account"},
                {"R24", "Duplicate entry", "RDFI has received a duplicate entry"},
                {"R25", "Addenda error", "Improper formatting of the addenda record information"},
                {"R26", "Mandatory field error", "Improper information in one of the mandatory fields"},
                {"R27", "Trace number error", "Original entry trace number is not valid for return entry; or addenda trace numbers do not correspond with entry detail record"},
                {"R28", "Transit routing number check digit error", "Check digit for the transit routing number is incorrect"},
                {"R29", "Corporate customer advises not authorized", "RDFI has bee notified by corporate receiver that debit entry of originator is not authorized"},
                {"R30", "RDFI not participant in check truncation program", "Financial institution not participating in automated check safekeeping application"},
                {"R31", "Permissible return entry (CCD and CTX only)", "RDFI has been notified by the ODFI that it agrees to accept a CCD or CTX return entry"},
                {"R32", "RDFI non-settlement", "RDFI is not able to settle the entry"},
                {"R33", "Return of XCK entry", "RDFI determines at its sole discretion to return an XCK entry; an XCK return entry may be initiated by midnight of the sixtieth day following the settlement date if the XCK entry"},
                {"R34", "Limited participation RDFI", "RDFI participation has been limited by a federal or state supervisor"},
                {"R35", "Return of improper debit entry", "ACH debit not permitted for use with the CIE standard entry class code (except for reversals)"},
                {"R37", "Source Document Presented for Payment (Adjustment Entry)", "The source document to which an ARC, BOC or POP entry relateshas been presented for payment. RDFI must obtain a Written Statement and return the entry within 60 days following Settlement Date"},
                {"R38", "Stop Payment on Source Document (Adjustment Entry)", "A stop payment has been placed on the source document to which the ARC or BOC entry relates. RDFI must return no later than 60 days following Settlement Date. No Written Statement is required as the original stop payment form covers the return"},
                {"R39", "Improper Source Document", "The RDFI has determined the source document used for the ARC, BOC or POP entry to its Receiverâ€™s account is improper."},
                {"R50", "State Law Affecting RCK Acceptance", "RDFI is located in a state that has not adopted Revised Article 4 of the UCC or the RDFI is located in a state that requires all canceled checks to be returned within the periodic statement"},
                {"R51", "Item Related to RCK Entry is Ineligible or RCK Entry is Improper", "The item to which the RCK entry relates was not eligible, Originator did not provide notice of the RCK policy, signature on the item was not genuine, the item has been altered or amount of the entry was not accurately obtained from the item. RDFI must obtain a Written Statement and return the entry within 60 days following Settlement Date"},
                {"R52", "Stop Payment on Item (Adjustment Entry)", "A stop payment has been placed on the item to which the RCK entry relates. RDFI must return no later than 60 days following Settlement Date. No Written Statement is required as the original stop payment form covers the return."},
                {"R53", "Item and RCK Entry Presented for Payment (Adjustment Entry)", "Both the RCK entry and check have been presented forpayment. RDFI must obtain a Written Statement and return the entry within 60 days following Settlement Date"},
                // More return codes will be added when more SEC types are added to the library.
        }
        // populate the map
        for _, code := range codes </span><span class="cov8" title="1">{
                dict[code.Code] = &amp;code
        }</span>
        <span class="cov8" title="1">return dict</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "fmt"
        "strconv"
        "strings"
)

// Batch holds the Batch Header and Batch Control and all Entry Records for PPD Entries
type batch struct {
        // ID is a client defined string used as a reference to this record.
        ID      string         `json:"id"`
        Header  *BatchHeader   `json:"batchHeader,omitempty"`
        Entries []*EntryDetail `json:"entryDetails,omitempty"`
        Control *BatchControl  `json:"batchControl,omitempty"`

        // category defines if the entry is a Forward, Return, or NOC
        category string
        // Converters is composed for ACH to GoLang Converters
        converters
}

// NewBatch takes a BatchHeader and returns a matching SEC code batch type that is a batcher. Returns an error if the SEC code is not supported.
func NewBatch(bh *BatchHeader) (Batcher, error) <span class="cov8" title="1">{
        switch bh.StandardEntryClassCode </span>{
        case "ARC":<span class="cov8" title="1">
                return NewBatchARC(bh), nil</span>
        case "BOC":<span class="cov8" title="1">
                return NewBatchBOC(bh), nil</span>
        case "CCD":<span class="cov8" title="1">
                return NewBatchCCD(bh), nil</span>
        case "COR":<span class="cov8" title="1">
                return NewBatchCOR(bh), nil</span>
        case "POP":<span class="cov8" title="1">
                return NewBatchPOP(bh), nil</span>
        case "POS":<span class="cov8" title="1">
                return NewBatchPOS(bh), nil</span>
        case "PPD":<span class="cov8" title="1">
                return NewBatchPPD(bh), nil</span>
        case "RCK":<span class="cov8" title="1">
                return NewBatchRCK(bh), nil</span>
        case "TEL":<span class="cov8" title="1">
                return NewBatchTEL(bh), nil</span>
        case "WEB":<span class="cov8" title="1">
                return NewBatchWEB(bh), nil</span>
        default:</span><span class="cov8" title="1">
        }
        <span class="cov8" title="1">msg := fmt.Sprintf(msgFileNoneSEC, bh.StandardEntryClassCode)
        return nil, &amp;FileError{FieldName: "StandardEntryClassCode", Msg: msg}</span>
}

// verify checks basic valid NACHA batch rules. Assumes properly parsed records. This does not mean it is a valid batch as validity is tied to each batch type
func (batch *batch) verify() error <span class="cov8" title="1">{
        batchNumber := batch.Header.BatchNumber

        // verify field inclusion in all the records of the batch.
        if err := batch.isFieldInclusion(); err != nil </span><span class="cov8" title="1">{
                // convert the field error in to a batch error for a consistent api
                if e, ok := err.(*FieldError); ok </span><span class="cov8" title="1">{
                        return &amp;BatchError{BatchNumber: batchNumber, FieldName: e.FieldName, Msg: e.Msg}
                }</span>
                <span class="cov0" title="0">return &amp;BatchError{BatchNumber: batchNumber, FieldName: "FieldError", Msg: err.Error()}</span>
        }
        // validate batch header and control codes are the same
        <span class="cov8" title="1">if batch.Header.ServiceClassCode != batch.Control.ServiceClassCode </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchHeaderControlEquality, batch.Header.ServiceClassCode, batch.Control.ServiceClassCode)
                return &amp;BatchError{BatchNumber: batchNumber, FieldName: "ServiceClassCode", Msg: msg}
        }</span>
        // Company Identification must match the Company ID from the batch header record
        <span class="cov8" title="1">if batch.Header.CompanyIdentification != batch.Control.CompanyIdentification </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchHeaderControlEquality, batch.Header.CompanyIdentification, batch.Control.CompanyIdentification)
                return &amp;BatchError{BatchNumber: batchNumber, FieldName: "CompanyIdentification", Msg: msg}
        }</span>
        // Control ODFIIdentification must be the same as batch header
        <span class="cov8" title="1">if batch.Header.ODFIIdentification != batch.Control.ODFIIdentification </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchHeaderControlEquality, batch.Header.ODFIIdentification, batch.Control.ODFIIdentification)
                return &amp;BatchError{BatchNumber: batchNumber, FieldName: "ODFIIdentification", Msg: msg}
        }</span>
        // batch number header and control must match
        <span class="cov8" title="1">if batch.Header.BatchNumber != batch.Control.BatchNumber </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchHeaderControlEquality, batch.Header.ODFIIdentification, batch.Control.ODFIIdentification)
                return &amp;BatchError{BatchNumber: batchNumber, FieldName: "BatchNumber", Msg: msg}
        }</span>

        <span class="cov8" title="1">if err := batch.isBatchEntryCount(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := batch.isSequenceAscending(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := batch.isBatchAmount(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := batch.isEntryHash(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := batch.isOriginatorDNE(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := batch.isTraceNumberODFI(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // TODO this is specific to batch SEC types and should be called by that validator
        <span class="cov8" title="1">if err := batch.isAddendaSequence(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return batch.isCategory()</span>
}

// Build creates valid batch by building sequence numbers and batch batch control. An error is returned if
// the batch being built has invalid records.
func (batch *batch) build() error <span class="cov8" title="1">{
        // Requires a valid BatchHeader
        if err := batch.Header.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if len(batch.Entries) &lt;= 0 </span><span class="cov8" title="1">{
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "entries", Msg: msgBatchEntries}
        }</span>
        // Create record sequence numbers
        <span class="cov8" title="1">entryCount := 0
        seq := 1
        for i, entry := range batch.Entries </span><span class="cov8" title="1">{
                entryCount = entryCount + 1 + len(entry.Addendum)
                currentTraceNumberODFI, err := strconv.Atoi(entry.TraceNumberField()[:8])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">batchHeaderODFI, err := strconv.Atoi(batch.Header.ODFIIdentificationField()[:8])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Add a sequenced TraceNumber if one is not already set. Have to keep original trance number Return and NOC entries
                <span class="cov8" title="1">if currentTraceNumberODFI != batchHeaderODFI </span><span class="cov8" title="1">{
                        batch.Entries[i].SetTraceNumber(batch.Header.ODFIIdentification, seq)
                }</span>
                <span class="cov8" title="1">seq++
                addendaSeq := 1
                for x := range entry.Addendum </span><span class="cov8" title="1">{
                        // sequences don't exist in NOC or Return addenda
                        if a, ok := batch.Entries[i].Addendum[x].(*Addenda05); ok </span><span class="cov8" title="1">{
                                a.SequenceNumber = addendaSeq
                                a.EntryDetailSequenceNumber = batch.parseNumField(batch.Entries[i].TraceNumberField()[8:])
                        }</span>
                        <span class="cov8" title="1">addendaSeq++</span>
                }
        }

        // build a BatchControl record
        <span class="cov8" title="1">bc := NewBatchControl()
        bc.ServiceClassCode = batch.Header.ServiceClassCode
        bc.CompanyIdentification = batch.Header.CompanyIdentification
        bc.ODFIIdentification = batch.Header.ODFIIdentification
        bc.BatchNumber = batch.Header.BatchNumber
        bc.EntryAddendaCount = entryCount
        bc.EntryHash = batch.parseNumField(batch.calculateEntryHash())
        bc.TotalCreditEntryDollarAmount, bc.TotalDebitEntryDollarAmount = batch.calculateBatchAmounts()
        batch.Control = bc

        return nil</span>
}

// SetHeader appends an BatchHeader to the Batch
func (batch *batch) SetHeader(batchHeader *BatchHeader) <span class="cov8" title="1">{
        batch.Header = batchHeader
}</span>

// GetHeader returns the current Batch header
func (batch *batch) GetHeader() *BatchHeader <span class="cov8" title="1">{
        return batch.Header
}</span>

// SetControl appends an BatchControl to the Batch
func (batch *batch) SetControl(batchControl *BatchControl) <span class="cov8" title="1">{
        batch.Control = batchControl
}</span>

// GetControl returns the current Batch Control
func (batch *batch) GetControl() *BatchControl <span class="cov8" title="1">{
        return batch.Control
}</span>

// GetEntries returns a slice of entry details for the batch
func (batch *batch) GetEntries() []*EntryDetail <span class="cov8" title="1">{
        return batch.Entries
}</span>

// AddEntry appends an EntryDetail to the Batch
func (batch *batch) AddEntry(entry *EntryDetail) <span class="cov8" title="1">{
        batch.category = entry.Category
        batch.Entries = append(batch.Entries, entry)
}</span>

// IsReturn is true if the batch contains an Entry Return
func (batch *batch) Category() string <span class="cov8" title="1">{
        return batch.category
}</span>

// isFieldInclusion iterates through all the records in the batch and verifies against default fields
func (batch *batch) isFieldInclusion() error <span class="cov8" title="1">{
        if err := batch.Header.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                if err := entry.Validate(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, addenda := range entry.Addendum </span><span class="cov8" title="1">{
                        if err := addenda.Validate(); err != nil </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                }
        }
        <span class="cov8" title="1">return batch.Control.Validate()</span>
}

// isBatchEntryCount validate Entry count is accurate
// The Entry/Addenda Count Field is a tally of each Entry Detail and Addenda
// Record processed within the batch
func (batch *batch) isBatchEntryCount() error <span class="cov8" title="1">{
        entryCount := 0
        for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                entryCount = entryCount + 1 + len(entry.Addendum)
        }</span>
        <span class="cov8" title="1">if entryCount != batch.Control.EntryAddendaCount </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchCalculatedControlEquality, entryCount, batch.Control.EntryAddendaCount)
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "EntryAddendaCount", Msg: msg}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// isBatchAmount validate Amount is the same as what is in the Entries
// The Total Debit and Credit Entry Dollar Amount fields contain accumulated
// Entry Detail debit and credit totals within a given batch
func (batch *batch) isBatchAmount() error <span class="cov8" title="1">{
        credit, debit := batch.calculateBatchAmounts()
        if debit != batch.Control.TotalDebitEntryDollarAmount </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchCalculatedControlEquality, debit, batch.Control.TotalDebitEntryDollarAmount)
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "TotalDebitEntryDollarAmount", Msg: msg}
        }</span>

        <span class="cov8" title="1">if credit != batch.Control.TotalCreditEntryDollarAmount </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchCalculatedControlEquality, credit, batch.Control.TotalCreditEntryDollarAmount)
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "TotalCreditEntryDollarAmount", Msg: msg}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (batch *batch) calculateBatchAmounts() (credit int, debit int) <span class="cov8" title="1">{
        for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                if entry.TransactionCode == 21 || entry.TransactionCode == 22 || entry.TransactionCode == 23 || entry.TransactionCode == 32 || entry.TransactionCode == 33 </span><span class="cov8" title="1">{
                        credit = credit + entry.Amount
                }</span>
                <span class="cov8" title="1">if entry.TransactionCode == 26 || entry.TransactionCode == 27 || entry.TransactionCode == 28 || entry.TransactionCode == 36 || entry.TransactionCode == 37 || entry.TransactionCode == 38 </span><span class="cov8" title="1">{
                        debit = debit + entry.Amount
                }</span>
        }
        <span class="cov8" title="1">return credit, debit</span>
}

// isSequenceAscending Individual Entry Detail Records within individual batches must
// be in ascending Trace Number order (although Trace Numbers need not necessarily be consecutive).
func (batch *batch) isSequenceAscending() error <span class="cov8" title="1">{
        lastSeq := -1
        for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                if entry.TraceNumber &lt;= lastSeq </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchAscending, entry.TraceNumber, lastSeq)
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "TraceNumber", Msg: msg}
                }</span>
                <span class="cov8" title="1">lastSeq = entry.TraceNumber</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// isEntryHash validates the hash by recalculating the result
func (batch *batch) isEntryHash() error <span class="cov8" title="1">{
        hashField := batch.calculateEntryHash()
        if hashField != batch.Control.EntryHashField() </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchCalculatedControlEquality, hashField, batch.Control.EntryHashField())
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "EntryHash", Msg: msg}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// calculateEntryHash This field is prepared by hashing the 8-digit Routing Number in each entry.
// The Entry Hash provides a check against inadvertent alteration of data
func (batch *batch) calculateEntryHash() string <span class="cov8" title="1">{
        hash := 0
        for _, entry := range batch.Entries </span><span class="cov8" title="1">{

                entryRDFI, _ := strconv.Atoi(entry.RDFIIdentification)

                hash = hash + entryRDFI
        }</span>
        <span class="cov8" title="1">return batch.numericField(hash, 10)</span>
}

// The Originator Status Code is not equal to â€œ2â€ for DNE if the Transaction Code is 23 or 33
func (batch *batch) isOriginatorDNE() error <span class="cov8" title="1">{
        if batch.Header.OriginatorStatusCode != 2 </span><span class="cov8" title="1">{
                for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                        if entry.TransactionCode == 23 || entry.TransactionCode == 33 </span><span class="cov8" title="1">{
                                msg := fmt.Sprintf(msgBatchOriginatorDNE, batch.Header.OriginatorStatusCode)
                                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "OriginatorStatusCode", Msg: msg}
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// isTraceNumberODFI checks if the first 8 positions of the entry detail trace number
// match the batch header ODFI
func (batch *batch) isTraceNumberODFI() error <span class="cov8" title="1">{
        for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                if batch.Header.ODFIIdentificationField() != entry.TraceNumberField()[:8] </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchTraceNumberNotODFI, batch.Header.ODFIIdentificationField(), entry.TraceNumberField()[:8])
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "ODFIIdentificationField", Msg: msg}
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isAddendaSequence check multiple errors on addenda records in the batch entries
func (batch *batch) isAddendaSequence() error <span class="cov8" title="1">{
        for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                if len(entry.Addendum) &gt; 0 </span><span class="cov8" title="1">{
                        // addenda without indicator flag of 1
                        if entry.AddendaRecordIndicator != 1 </span><span class="cov8" title="1">{
                                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "AddendaRecordIndicator", Msg: msgBatchAddendaIndicator}
                        }</span>
                        <span class="cov8" title="1">lastSeq := -1
                        // check if sequence is ascending
                        for _, addenda := range entry.Addendum </span><span class="cov8" title="1">{
                                // sequences don't exist in NOC or Return addenda
                                if a, ok := addenda.(*Addenda05); ok </span><span class="cov8" title="1">{

                                        if a.SequenceNumber &lt; lastSeq </span><span class="cov8" title="1">{
                                                msg := fmt.Sprintf(msgBatchAscending, a.SequenceNumber, lastSeq)
                                                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "SequenceNumber", Msg: msg}
                                        }</span>
                                        <span class="cov8" title="1">lastSeq = a.SequenceNumber
                                        // check that we are in the correct Entry Detail
                                        if !(a.EntryDetailSequenceNumberField() == entry.TraceNumberField()[8:]) </span><span class="cov8" title="1">{
                                                msg := fmt.Sprintf(msgBatchAddendaTraceNumber, a.EntryDetailSequenceNumberField(), entry.TraceNumberField()[8:])
                                                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "TraceNumber", Msg: msg}
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// isAddendaCount iterates through each entry detail and checks the number of addendum is greater than the count parameter otherwise it returns an error.
// Following SEC codes allow for none or one Addendum
// "PPD", "WEB", "CCD", "CIE", "DNE", "MTE", "POS", "SHR"
func (batch *batch) isAddendaCount(count int) error <span class="cov8" title="1">{
        for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                if len(entry.Addendum) &gt; count </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchAddendaCount, len(entry.Addendum), count, batch.Header.StandardEntryClassCode)
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "AddendaCount", Msg: msg}
                }</span>

        }
        <span class="cov8" title="1">return nil</span>
}

// isTypeCode takes a TypeCode string and verifies Addenda records match
func (batch *batch) isTypeCode(typeCode string) error <span class="cov8" title="1">{
        for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                for _, addenda := range entry.Addendum </span><span class="cov8" title="1">{
                        if addenda.TypeCode() != typeCode </span><span class="cov8" title="1">{
                                msg := fmt.Sprintf(msgBatchTypeCode, addenda.TypeCode(), typeCode, batch.Header.StandardEntryClassCode)
                                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "TypeCode", Msg: msg}
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// isCategory verifies that a Forward and Return Category are not in the same batch
func (batch *batch) isCategory() error <span class="cov8" title="1">{
        category := batch.GetEntries()[0].Category
        if len(batch.Entries) &gt; 1 </span><span class="cov8" title="1">{
                for i := 1; i &lt; len(batch.Entries); i++ </span><span class="cov8" title="1">{
                        if batch.Entries[i].Category == CategoryNOC </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if batch.Entries[i].Category != category </span><span class="cov8" title="1">{
                                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "Category", Msg: msgBatchForwardReturn}
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// isPaymentTypeCode checks that the Entry detail records have either:
// "R" For a recurring WEB Entry
// "S" For a Single-Entry WEB Entry
func (batch *batch) isPaymentTypeCode() error <span class="cov8" title="1">{
        for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                if !strings.Contains(strings.ToUpper(entry.PaymentTypeField()), "S") &amp;&amp; !strings.Contains(strings.ToUpper(entry.PaymentTypeField()), "R") </span><span class="cov0" title="0">{
                        // TODO dead code because PaymentTypeField always returns S regardless of Discretionary Data value
                        msg := fmt.Sprintf(msgBatchWebPaymentType, entry.PaymentTypeField())
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "PaymentType", Msg: msg}
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import "fmt"

// BatchARC holds the BatchHeader and BatchControl and all EntryDetail for ARC Entries.
//
// Accounts Receivable Entry (ARC). A consumer check converted to a one-time ACH debit.
// The Accounts Receivable (ARC) Entry provides billers the opportunity to initiate single-entry ACH
// debits to customer accounts by converting checks at the point of receipt through the U.S. mail, at
// a drop box location or in-person for payment of a bill at a manned location. The biller is required
// to provide the customer with notice prior to the acceptance of the check that states the receipt of
// the customerâ€™s check will be deemed as the authorization for an ARC debit entry to the customerâ€™s
// account. The provision of the notice and the receipt of the check together constitute authorization
// for the ARC entry. The customerâ€™s check is solely be used as a source document to obtain the routing
// number, account number and check serial number.
//
// The difference between ARC and POP is that ARC can result from a check mailed in whereas POP is in-person.
type BatchARC struct {
        batch
}

// NewBatchARC returns a *BatchARC
func NewBatchARC(bh *BatchHeader) *BatchARC <span class="cov8" title="1">{
        batch := new(BatchARC)
        batch.SetControl(NewBatchControl())
        batch.SetHeader(bh)
        return batch
}</span>

// Validate checks valid NACHA batch rules. Assumes properly parsed records.
func (batch *BatchARC) Validate() error <span class="cov8" title="1">{
        // basic verification of the batch before we validate specific rules.
        if err := batch.verify(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Add configuration based validation for this type.

        // Batch ARC cannot have an addenda record
        <span class="cov8" title="1">if err := batch.isAddendaCount(0); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Add type specific validation.
        <span class="cov8" title="1">if batch.Header.StandardEntryClassCode != "ARC" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchSECType, batch.Header.StandardEntryClassCode, "ARC")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "StandardEntryClassCode", Msg: msg}
        }</span>

        // ARC detail entries can only be a debit, ServiceClassCode must allow debits
        <span class="cov8" title="1">switch batch.Header.ServiceClassCode </span>{
        case 200, 220, 280:<span class="cov8" title="1">
                msg := fmt.Sprintf(msgBatchServiceClassCode, batch.Header.ServiceClassCode, "ARC")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "ServiceClassCode", Msg: msg}</span>
        }

        <span class="cov8" title="1">for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                // ARC detail entries must be a debit
                if entry.CreditOrDebit() != "D" </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchTransactionCodeCredit, entry.TransactionCode)
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "TransactionCode", Msg: msg}
                }</span>

                // Amount must be 25,000 or less
                <span class="cov8" title="1">if entry.Amount &gt; 2500000 </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchAmount, "25,000", "ARC")
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "Amount", Msg: msg}
                }</span>

                // CheckSerialNumber underlying IdentificationNumber, must be defined
                <span class="cov8" title="1">if entry.IdentificationNumber == "" </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchCheckSerialNumber, "ARC")
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "CheckSerialNumber", Msg: msg}
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Create takes Batch Header and Entries and builds a valid batch
func (batch *BatchARC) Create() error <span class="cov8" title="1">{
        // generates sequence numbers and batch control
        if err := batch.build(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Additional steps specific to batch type
        // ...

        <span class="cov8" title="1">return batch.Validate()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import "fmt"

// BatchBOC holds the BatchHeader and BatchControl and all EntryDetail for BOC Entries.
//
// Back Office Conversion (BOC) A single entry debit initiated at the point of purchase
// or at a manned bill payment location to transfer funds through conversion to an
// ACH debit entry during back office processing.
//
// BOC allows retailers/billers, and ODFIs acting as Originators,
// to electronically convert checks received at the point-of-purchase as well as at a
// manned bill payment location into a single-entry ACH debit. The authorization to
// convert the check will be obtained through a notice at the checkout or manned bill
// payment location (e.g., loan payment at financial institutionâ€™s teller window) and the
// receipt of the Receiverâ€™s check. The decision to process the check item as an ACH debit
// will be made in the â€œback officeâ€ instead of at the point-of-purchase. The customerâ€™s
// check will solely be used as a source document to obtain the routing number, account
// number and check serial number.
//
// Unlike ARC entries, BOC conversions require the customer to be present and a notice that
// checks may be converted to BOC ACH entries be posted.
type BatchBOC struct {
        batch
}

// NewBatchBOC returns a *BatchBOC
func NewBatchBOC(bh *BatchHeader) *BatchBOC <span class="cov8" title="1">{
        batch := new(BatchBOC)
        batch.SetControl(NewBatchControl())
        batch.SetHeader(bh)
        return batch
}</span>

// Validate checks valid NACHA batch rules. Assumes properly parsed records.
func (batch *BatchBOC) Validate() error <span class="cov8" title="1">{
        // basic verification of the batch before we validate specific rules.
        if err := batch.verify(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Add configuration based validation for this type.

        // Batch BOC cannot have an addenda record
        <span class="cov8" title="1">if err := batch.isAddendaCount(0); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Add type specific validation.
        <span class="cov8" title="1">if batch.Header.StandardEntryClassCode != "BOC" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchSECType, batch.Header.StandardEntryClassCode, "BOC")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "StandardEntryClassCode", Msg: msg}
        }</span>

        // BOC detail entries can only be a debit, ServiceClassCode must allow debits
        <span class="cov8" title="1">switch batch.Header.ServiceClassCode </span>{
        case 200, 220, 280:<span class="cov8" title="1">
                msg := fmt.Sprintf(msgBatchServiceClassCode, batch.Header.ServiceClassCode, "RCK")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "ServiceClassCode", Msg: msg}</span>
        }

        <span class="cov8" title="1">for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                // BOC detail entries must be a debit
                if entry.CreditOrDebit() != "D" </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchTransactionCodeCredit, entry.TransactionCode)
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "TransactionCode", Msg: msg}
                }</span>

                // Amount must be 25,000 or less
                <span class="cov8" title="1">if entry.Amount &gt; 2500000 </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchAmount, "25,000", "BOC")
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "Amount", Msg: msg}
                }</span>

                // CheckSerialNumber underlying IdentificationNumber, must be defined
                <span class="cov8" title="1">if entry.IdentificationNumber == "" </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchCheckSerialNumber, "BOC")
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "CheckSerialNumber", Msg: msg}
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Create takes Batch Header and Entries and builds a valid batch
func (batch *BatchBOC) Create() error <span class="cov8" title="1">{
        // generates sequence numbers and batch control
        if err := batch.build(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Additional steps specific to batch type
        // ...

        <span class="cov8" title="1">return batch.Validate()</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "fmt"
)

// BatchCCD is a batch file that handles SEC payment type CCD amd CCD+.
// Corporate credit or debit. Identifies an Entry initiated by an Organization to transfer funds to or from an account of that Organization or another Organization.
// For commercial accounts only.
type BatchCCD struct {
        batch
}

// NewBatchCCD returns a *BatchCCD
func NewBatchCCD(bh *BatchHeader) *BatchCCD <span class="cov8" title="1">{
        batch := new(BatchCCD)
        batch.SetControl(NewBatchControl())
        batch.SetHeader(bh)
        return batch
}</span>

// Validate ensures the batch meets NACHA rules specific to this batch type.
func (batch *BatchCCD) Validate() error <span class="cov8" title="1">{
        // basic verification of the batch before we validate specific rules.
        if err := batch.verify(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Add configuration based validation for this type.
        // Web can have up to one addenda per entry record
        <span class="cov8" title="1">if err := batch.isAddendaCount(1); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := batch.isTypeCode("05"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Add type specific validation.
        <span class="cov8" title="1">if batch.Header.StandardEntryClassCode != "CCD" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchSECType, batch.Header.StandardEntryClassCode, "CCD")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "StandardEntryClassCode", Msg: msg}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Create builds the batch sequence numbers and batch control. Additional creation
func (batch *BatchCCD) Create() error <span class="cov8" title="1">{
        // generates sequence numbers and batch control
        if err := batch.build(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return batch.Validate()</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "fmt"
)

// BatchCOR COR - Automated Notification of Change (NOC) or Refused Notification of Change
// This Standard Entry Class Code is used by an RDFI or ODFI when originating a Notification of Change or Refused Notification of Change in automated format.
// A Notification of Change may be created by an RDFI to notify the ODFI that a posted Entry or Prenotification Entry contains invalid or erroneous information and should be changed.
type BatchCOR struct {
        batch
}

var msgBatchCORAmount = "debit:%v credit:%v entry detail amount fields must be zero for SEC type COR"
var msgBatchCORAddenda = "found and 1 Addenda98 is required for SEC Type COR"
var msgBatchCORAddendaType = "%T found where Addenda98 is required for SEC type NOC"

// NewBatchCOR returns a *BatchCOR
func NewBatchCOR(bh *BatchHeader) *BatchCOR <span class="cov8" title="1">{
        batch := new(BatchCOR)
        batch.SetControl(NewBatchControl())
        batch.SetHeader(bh)
        return batch
}</span>

// Validate ensures the batch meets NACHA rules specific to this batch type.
func (batch *BatchCOR) Validate() error <span class="cov8" title="1">{
        // basic verification of the batch before we validate specific rules.
        if err := batch.verify(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Add configuration based validation for this type.
        // COR Addenda must be Addenda98
        <span class="cov8" title="1">if err := batch.isAddenda98(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Add type specific validation.
        <span class="cov8" title="1">if batch.Header.StandardEntryClassCode != "COR" </span><span class="cov0" title="0">{
                msg := fmt.Sprintf(msgBatchSECType, batch.Header.StandardEntryClassCode, "COR")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "StandardEntryClassCode", Msg: msg}
        }</span>

        // The Amount field must be zero
        // batch.verify calls batch.isBatchAmount which ensures the batch.Control values are accurate.
        <span class="cov8" title="1">if batch.Control.TotalCreditEntryDollarAmount != 0 || batch.Control.TotalDebitEntryDollarAmount != 0 </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchCORAmount, batch.Control.TotalCreditEntryDollarAmount, batch.Control.TotalDebitEntryDollarAmount)
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "Amount", Msg: msg}
        }</span>

        <span class="cov8" title="1">for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                // COR TransactionCode must be a Return or NOC transaction Code
                // Return/NOC of a credit  21, 31, 41, 51
                // Return/NOC of a debit 26, 36, 46, 56
                if entry.TransactionCodeDescription() != ReturnOrNoc </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchTransactionCode, entry.TransactionCode, "COR")
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "TransactionCode", Msg: msg}
                }</span>

        }

        <span class="cov8" title="1">return nil</span>
}

// Create builds the batch sequence numbers and batch control. Additional creation
func (batch *BatchCOR) Create() error <span class="cov8" title="1">{
        // generates sequence numbers and batch control
        if err := batch.build(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return batch.Validate()</span>
}

// isAddenda98 verifies that a Addenda98 exists for each EntryDetail and is Validated
func (batch *BatchCOR) isAddenda98() error <span class="cov8" title="1">{
        for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                // Addenda type must be equal to 1
                if len(entry.Addendum) != 1 </span><span class="cov8" title="1">{
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "Addendum", Msg: msgBatchCORAddenda}
                }</span>
                // Addenda type assertion must be Addenda98
                <span class="cov8" title="1">addenda98, ok := entry.Addendum[0].(*Addenda98)
                if !ok </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchCORAddendaType, entry.Addendum[0])
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "Addendum", Msg: msg}
                }</span>
                // Addenda98 must be Validated
                <span class="cov8" title="1">if err := addenda98.Validate(); err != nil </span><span class="cov8" title="1">{
                        // convert the field error in to a batch error for a consistent api
                        if e, ok := err.(*FieldError); ok </span><span class="cov8" title="1">{
                                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: e.FieldName, Msg: e.Msg}
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "fmt"
        "strconv"
        "strings"
)

// BatchControl contains entry counts, dollar total and has totals for all
// entries contained in the preceding batch
type BatchControl struct {
        // ID is a client defined string used as a reference to this record.
        ID string `json:"id"`
        // RecordType defines the type of record in the block.
        recordType string
        // ServiceClassCode ACH Mixed Debits and Credits â€˜200â€™
        // ACH Credits Only â€˜220â€™
        // ACH Debits Only â€˜225'
        // Same as 'ServiceClassCode' in BatchHeaderRecord
        ServiceClassCode int `json:"serviceClassCode"`
        // EntryAddendaCount is a tally of each Entry Detail Record and each Addenda
        // Record processed, within either the batch or file as appropriate.
        EntryAddendaCount int `json:"entryAddendaÃ‡ount"`
        // validate the Receiving DFI Identification in each Entry Detail Record is hashed
        // to provide a check against inadvertent alteration of data contents due
        // to hardware failure or program error
        //
        // In this context the Entry Hash is the sum of the corresponding fields in the
        // Entry Detail Records on the file.
        EntryHash int `json:"entryHash"`
        // TotalDebitEntryDollarAmount Contains accumulated Entry debit totals within the batch.
        TotalDebitEntryDollarAmount int `json:"totalDebit"`
        // TotalCreditEntryDollarAmount Contains accumulated Entry credit totals within the batch.
        TotalCreditEntryDollarAmount int `json:"totalCredit"`
        // CompanyIdentification is an alphameric code used to identify an Originator
        // The Company Identification Field must be included on all
        // prenotification records and on each entry initiated pursuant to such
        // prenotification. The Company ID may begin with the ANSI one-digit
        // Identification Code Designator (ICD), followed by the identification
        // number The ANSI Identification Numbers and related Identification Code
        // Designator (ICD) are:
        //
        // IRS Employer Identification Number (EIN) "1"
        // Data Universal Numbering Systems (DUNS) "3"
        // User Assigned Number "9"
        CompanyIdentification string `json:"companyIdentification"`
        // MessageAuthenticationCode the MAC is an eight character code derived from a special key used in
        // conjunction with the DES algorithm. The purpose of the MAC is to
        // validate the authenticity of ACH entries. The DES algorithm and key
        // message standards must be in accordance with standards adopted by the
        // American National Standards Institute. The remaining eleven characters
        // of this field are blank.
        MessageAuthenticationCode string `json:"messageAuthentication,omitempty"`
        // Reserved for the future - Blank, 6 characters long
        reserved string
        // ODFIIdentification the routing number is used to identify the DFI originating entries within a given branch.
        ODFIIdentification string `json:"ODFIIdentification"`
        // BatchNumber this number is assigned in ascending sequence to each batch by the ODFI
        // or its Sending Point in a given file of entries. Since the batch number
        // in the Batch Header Record and the Batch Control Record is the same,
        // the ascending sequence number should be assigned by batch and not by record.
        BatchNumber int `json:"batchNumber"`
        // validator is composed for data validation
        validator
        // converters is composed for ACH to golang Converters
        converters
}

// Parse takes the input record string and parses the EntryDetail values
func (bc *BatchControl) Parse(record string) <span class="cov8" title="1">{
        // 1-1 Always "8"
        bc.recordType = "8"
        // 2-4 This is the same as the "Service code" field in previous Batch Header Record
        bc.ServiceClassCode = bc.parseNumField(record[1:4])
        // 5-10 Total number of Entry Detail Record in the batch
        bc.EntryAddendaCount = bc.parseNumField(record[4:10])
        // 11-20 Total of all positions 4-11 on each Entry Detail Record in the batch. This is essentially the sum of all the RDFI routing numbers in the batch.
        // If the sum exceeds 10 digits (because you have lots of Entry Detail Records), lop off the most significant digits of the sum until there are only 10
        bc.EntryHash = bc.parseNumField(record[10:20])
        // 21-32 Number of cents of debit entries within the batch
        bc.TotalDebitEntryDollarAmount = bc.parseNumField(record[20:32])
        // 33-44 Number of cents of credit entries within the batch
        bc.TotalCreditEntryDollarAmount = bc.parseNumField(record[32:44])
        // 45-54 This is the same as the "Company identification" field in previous Batch Header Record
        bc.CompanyIdentification = strings.TrimSpace(record[44:54])
        // 55-73 Seems to always be blank
        bc.MessageAuthenticationCode = strings.TrimSpace(record[54:73])
        // 74-79 Always blank (just fill with spaces)
        bc.reserved = "      "
        // 80-87 This is the same as the "ODFI identification" field in previous Batch Header Record
        bc.ODFIIdentification = bc.parseStringField(record[79:87])
        // 88-94 This is the same as the "Batch number" field in previous Batch Header Record
        bc.BatchNumber = bc.parseNumField(record[87:94])
}</span>

// NewBatchControl returns a new BatchControl with default values for none exported fields
func NewBatchControl() *BatchControl <span class="cov8" title="1">{
        return &amp;BatchControl{
                recordType:       "8",
                ServiceClassCode: 200,
                EntryHash:        1,
                BatchNumber:      1,
        }
}</span>

// String writes the BatchControl struct to a 94 character string.
func (bc *BatchControl) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v",
                bc.recordType,
                bc.ServiceClassCode,
                bc.EntryAddendaCountField(),
                bc.EntryHashField(),
                bc.TotalDebitEntryDollarAmountField(),
                bc.TotalCreditEntryDollarAmountField(),
                bc.CompanyIdentificationField(),
                bc.MessageAuthenticationCodeField(),
                "      ",
                bc.ODFIIdentificationField(),
                bc.BatchNumberField(),
        )
}</span>

// Validate performs NACHA format rule checks on the record and returns an error if not Validated
// The first error encountered is returned and stops that parsing.
func (bc *BatchControl) Validate() error <span class="cov8" title="1">{
        if err := bc.fieldInclusion(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if bc.recordType != "8" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgRecordType, 7)
                return &amp;FieldError{FieldName: "recordType", Value: bc.recordType, Msg: msg}
        }</span>
        <span class="cov8" title="1">if err := bc.isServiceClass(bc.ServiceClassCode); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ServiceClassCode", Value: strconv.Itoa(bc.ServiceClassCode), Msg: err.Error()}
        }</span>

        <span class="cov8" title="1">if err := bc.isAlphanumeric(bc.CompanyIdentification); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "CompanyIdentification", Value: bc.CompanyIdentification, Msg: err.Error()}
        }</span>

        <span class="cov8" title="1">if err := bc.isAlphanumeric(bc.MessageAuthenticationCode); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "MessageAuthenticationCode", Value: bc.MessageAuthenticationCode, Msg: err.Error()}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// fieldInclusion validate mandatory fields are not default values. If fields are
// invalid the ACH transfer will be returned.
func (bc *BatchControl) fieldInclusion() error <span class="cov8" title="1">{
        if bc.recordType == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "recordType", Value: bc.recordType, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if bc.ServiceClassCode == 0 </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ServiceClassCode", Value: strconv.Itoa(bc.ServiceClassCode), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if bc.ODFIIdentification == "000000000" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ODFIIdentification", Value: bc.ODFIIdentificationField(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// EntryAddendaCountField gets a string of the addenda count zero padded
func (bc *BatchControl) EntryAddendaCountField() string <span class="cov8" title="1">{
        return bc.numericField(bc.EntryAddendaCount, 6)
}</span>

// EntryHashField get a zero padded EntryHash
func (bc *BatchControl) EntryHashField() string <span class="cov8" title="1">{
        return bc.numericField(bc.EntryHash, 10)
}</span>

//TotalDebitEntryDollarAmountField get a zero padded Debity Entry Amount
func (bc *BatchControl) TotalDebitEntryDollarAmountField() string <span class="cov8" title="1">{
        return bc.numericField(bc.TotalDebitEntryDollarAmount, 12)
}</span>

// TotalCreditEntryDollarAmountField get a zero padded Credit Entry Amount
func (bc *BatchControl) TotalCreditEntryDollarAmountField() string <span class="cov8" title="1">{
        return bc.numericField(bc.TotalCreditEntryDollarAmount, 12)
}</span>

// CompanyIdentificationField get the CompanyIdentification righ padded
func (bc *BatchControl) CompanyIdentificationField() string <span class="cov8" title="1">{
        return bc.alphaField(bc.CompanyIdentification, 10)
}</span>

// MessageAuthenticationCodeField get the MessageAuthenticationCode right padded
func (bc *BatchControl) MessageAuthenticationCodeField() string <span class="cov8" title="1">{
        return bc.alphaField(bc.MessageAuthenticationCode, 19)
}</span>

// ODFIIdentificationField get the odfi number zero padded
func (bc *BatchControl) ODFIIdentificationField() string <span class="cov8" title="1">{
        return bc.stringRTNField(bc.ODFIIdentification, 8)
}</span>

// BatchNumberField gets a string of the batch number zero padded
func (bc *BatchControl) BatchNumberField() string <span class="cov8" title="1">{
        return bc.numericField(bc.BatchNumber, 7)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "fmt"
        "strconv"
        "strings"
        "time"
)

// msgServiceClass

// BatchHeader identifies the originating entity and the type of transactions
// contained in the batch (i.e., the standard entry class, PPD for consumer, CCD
// or CTX for corporate). This record also contains the effective date, or desired
// settlement date, for all entries contained in this batch. The settlement date
// field is not entered as it is determined by the ACH operator
type BatchHeader struct {
        // ID is a client defined string used as a reference to this record.
        ID string `json:"id"`
        // RecordType defines the type of record in the block. 5
        recordType string

        // ServiceClassCode ACH Mixed Debits and Credits â€˜200â€™
        // ACH Credits Only â€˜220â€™
        // ACH Debits Only â€˜225'
        ServiceClassCode int `json:"serviceClassCode"`

        // CompanyName the company originating the entries in the batch
        CompanyName string `json:"companyName"`

        // CompanyDiscretionaryData allows Originators and/or ODFIs to include codes (one or more),
        // of significance only to them, to enable specialized handling of all
        // subsequent entries in that batch. There will be no standardized
        // interpretation for the value of the field. This field must be returned
        // intact on any return entry.
        CompanyDiscretionaryData string `json:"companyDiscretionaryData,omitempty"`

        // CompanyIdentification The 9 digit FEIN number (proceeded by a predetermined
        // alpha or numeric character) of the entity in the company name field
        CompanyIdentification string `json:"companyIdentification"`

        // StandardEntryClassCode
        // Identifies the payment type (product) found within an ACH batch-using a 3-character code.
        // The SEC Code pertains to all items within batch.
        // Determines format of the detail records.
        // Determines addenda records (required or optional PLUS one or up to 9,999 records).
        // Determines rules to follow (return time frames).
        // Some SEC codes require specific data in predetermined fields within the ACH record
        StandardEntryClassCode string `json:"standardEntryClassCode,omitempty"`

        // CompanyEntryDescription A description of the entries contained in the batch
        //
        //The Originator establishes the value of this field to provide a
        // description of the purpose of the entry to be displayed back to
        // the receive For example, "GAS BILL," "REG. SALARY," "INS. PREM,"
        // "SOC. SEC.," "DTC," "TRADE PAY," "PURCHASE," etc.
        //
        // This field must contain the word "REVERSAL" (left justified) when the
        // batch contains reversing entries.
        //
        // This field must contain the word "RECLAIM" (left justified) when the
        // batch contains reclamation entries.
        //
        // This field must contain the word "NONSETTLED" (left justified) when the
        // batch contains entries which could not settle.
        CompanyEntryDescription string `json:"companyEntryDescription,omitempty"`

        // CompanyDescriptiveDate except as otherwise noted below, the Originator establishes this field
        // as the date it would like to see displayed to the receiver for
        // descriptive purposes. This field is never used to control timing of any
        // computer or manual operation. It is solely for descriptive purposes.
        // The RDFI should not assume any specific format. Examples of possible
        // entries in this field are "011392,", "01 92," "JAN 13," "JAN 92," etc.
        CompanyDescriptiveDate string `json:"companyDescriptiveDate,omitempty"`

        // EffectiveEntryDate the date on which the entries are to settle
        EffectiveEntryDate time.Time `json:"effectiveEntryDate,omitempty"`

        // SettlementDate Leave blank, this field is inserted by the ACH operator
        settlementDate string

        // OriginatorStatusCode refers to the ODFI initiating the Entry.
        // 0 ADV File prepared by an ACH Operator.
        // 1 This code identifies the Originator as a depository financial institution.
        // 2 This code identifies the Originator as a Federal Government entity or agency.
        OriginatorStatusCode int `json:"originatorStatusCode,omitempty"`

        //ODFIIdentification First 8 digits of the originating DFI transit routing number
        ODFIIdentification string `json:"ODFIIdentification"`

        // BatchNumber is assigned in ascending sequence to each batch by the ODFI
        // or its Sending Point in a given file of entries. Since the batch number
        // in the Batch Header Record and the Batch Control Record is the same,
        // the ascending sequence number should be assigned by batch and not by
        // record.
        BatchNumber int `json:"batchNumber,omitempty"`

        // validator is composed for data validation
        validator

        // converters is composed for ACH to golang Converters
        converters
}

// NewBatchHeader returns a new BatchHeader with default values for non exported fields
func NewBatchHeader() *BatchHeader <span class="cov8" title="1">{
        bh := &amp;BatchHeader{
                recordType:           "5",
                OriginatorStatusCode: 0, //Prepared by an Originator
                BatchNumber:          1,
        }
        return bh
}</span>

// Parse takes the input record string and parses the BatchHeader values
func (bh *BatchHeader) Parse(record string) <span class="cov8" title="1">{
        // 1-1 Always "5"
        bh.recordType = "5"
        // 2-4 If the entries are credits, always "220". If the entries are debits, always "225"
        bh.ServiceClassCode = bh.parseNumField(record[1:4])
        // 5-20 Your company's name. This name may appear on the receiversâ€™ statements prepared by the RDFI.
        bh.CompanyName = strings.TrimSpace(record[4:20])
        // 21-40 Optional field you may use to describe the batch for internal accounting purposes
        bh.CompanyDiscretionaryData = strings.TrimSpace(record[20:40])
        // 41-50 A 10-digit number assigned to you by the ODFI once they approve you to
        // originate ACH files through them. This is the same as the "Immediate origin" field in File Header Record
        bh.CompanyIdentification = strings.TrimSpace(record[40:50])
        // 51-53 If the entries are PPD (credits/debits towards consumer account), use "PPD".
        // If the entries are CCD (credits/debits towards corporate account), use "CCD".
        // The difference between the 2 SEC codes are outside of the scope of this post.
        bh.StandardEntryClassCode = record[50:53]
        // 54-63 Your description of the transaction. This text will appear on the receiversâ€™ bank statement.
        // For example: "Payroll   "
        bh.CompanyEntryDescription = strings.TrimSpace(record[53:63])
        // 64-69 The date you choose to identify the transactions in YYMMDD format.
        // This date may be printed on the receiversâ€™ bank statement by the RDFI
        bh.CompanyDescriptiveDate = strings.TrimSpace(record[63:69])
        // 70-75 Date transactions are to be posted to the receiversâ€™ account.
        // You almost always want the transaction to post as soon as possible, so put tomorrow's date in YYMMDD format
        bh.EffectiveEntryDate = bh.parseSimpleDate(record[69:75])
        // 76-79 Always blank (just fill with spaces)
        bh.settlementDate = "   "
        // 79-79 Always 1
        bh.OriginatorStatusCode = bh.parseNumField(record[78:79])
        // 80-87 Your ODFI's routing number without the last digit. The last digit is simply a
        // checksum digit, which is why it is not necessary
        bh.ODFIIdentification = bh.parseStringField(record[79:87])
        // 88-94 Sequential number of this Batch Header Record
        // For example, put "1" if this is the first Batch Header Record in the file
        bh.BatchNumber = bh.parseNumField(record[87:94])
}</span>

// String writes the BatchHeader struct to a 94 character string.
func (bh *BatchHeader) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v",
                bh.recordType,
                bh.ServiceClassCode,
                bh.CompanyNameField(),
                bh.CompanyDiscretionaryDataField(),
                bh.CompanyIdentificationField(),
                bh.StandardEntryClassCode,
                bh.CompanyEntryDescriptionField(),
                bh.CompanyDescriptiveDateField(),
                bh.EffectiveEntryDateField(),
                bh.settlementDateField(),
                bh.OriginatorStatusCode,
                bh.ODFIIdentificationField(),
                bh.BatchNumberField(),
        )
}</span>

// Validate performs NACHA format rule checks on the record and returns an error if not Validated
// The first error encountered is returned and stops that parsing.
func (bh *BatchHeader) Validate() error <span class="cov8" title="1">{
        if err := bh.fieldInclusion(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if bh.recordType != "5" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgRecordType, 5)
                return &amp;FieldError{FieldName: "recordType", Value: bh.recordType, Msg: msg}
        }</span>
        <span class="cov8" title="1">if err := bh.isServiceClass(bh.ServiceClassCode); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ServiceClassCode", Value: strconv.Itoa(bh.ServiceClassCode), Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if err := bh.isSECCode(bh.StandardEntryClassCode); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "StandardEntryClassCode", Value: bh.StandardEntryClassCode, Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if err := bh.isOriginatorStatusCode(bh.OriginatorStatusCode); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "OriginatorStatusCode", Value: strconv.Itoa(bh.OriginatorStatusCode), Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if err := bh.isAlphanumeric(bh.CompanyName); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "CompanyName", Value: bh.CompanyName, Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if err := bh.isAlphanumeric(bh.CompanyDiscretionaryData); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "CompanyDiscretionaryData", Value: bh.CompanyDiscretionaryData, Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if err := bh.isAlphanumeric(bh.CompanyIdentification); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "CompanyIdentification", Value: bh.CompanyIdentification, Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if err := bh.isAlphanumeric(bh.CompanyEntryDescription); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "CompanyEntryDescription", Value: bh.CompanyEntryDescription, Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// fieldInclusion validate mandatory fields are not default values. If fields are
// invalid the ACH transfer will be returned.
func (bh *BatchHeader) fieldInclusion() error <span class="cov8" title="1">{
        if bh.recordType == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "recordType", Value: bh.recordType, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if bh.ServiceClassCode == 0 </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ServiceClassCode", Value: strconv.Itoa(bh.ServiceClassCode), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if bh.CompanyName == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "CompanyName", Value: bh.CompanyName, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if bh.CompanyIdentification == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "CompanyIdentification", Value: bh.CompanyIdentification, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if bh.StandardEntryClassCode == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "StandardEntryClassCode", Value: bh.StandardEntryClassCode, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if bh.CompanyEntryDescription == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "CompanyEntryDescription", Value: bh.CompanyEntryDescription, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if bh.ODFIIdentification == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ODFIIdentification", Value: bh.ODFIIdentificationField(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CompanyNameField get the CompanyName left padded
func (bh *BatchHeader) CompanyNameField() string <span class="cov8" title="1">{
        return bh.alphaField(bh.CompanyName, 16)
}</span>

// CompanyDiscretionaryDataField get the CompanyDiscretionaryData left padded
func (bh *BatchHeader) CompanyDiscretionaryDataField() string <span class="cov8" title="1">{
        return bh.alphaField(bh.CompanyDiscretionaryData, 20)
}</span>

// CompanyIdentificationField get the CompanyIdentification left padded
func (bh *BatchHeader) CompanyIdentificationField() string <span class="cov8" title="1">{
        return bh.alphaField(bh.CompanyIdentification, 10)
}</span>

// CompanyEntryDescriptionField get the CompanyEntryDescription left padded
func (bh *BatchHeader) CompanyEntryDescriptionField() string <span class="cov8" title="1">{
        return bh.alphaField(bh.CompanyEntryDescription, 10)
}</span>

// CompanyDescriptiveDateField get the CompanyDescriptiveDate left padded
func (bh *BatchHeader) CompanyDescriptiveDateField() string <span class="cov8" title="1">{
        return bh.alphaField(bh.CompanyDescriptiveDate, 6)
}</span>

// EffectiveEntryDateField get the EffectiveEntryDate in YYMMDD format
func (bh *BatchHeader) EffectiveEntryDateField() string <span class="cov8" title="1">{
        return bh.formatSimpleDate(bh.EffectiveEntryDate)
}</span>

// ODFIIdentificationField get the odfi number zero padded
func (bh *BatchHeader) ODFIIdentificationField() string <span class="cov8" title="1">{
        return bh.stringRTNField(bh.ODFIIdentification, 8)
}</span>

// BatchNumberField get the batch number zero padded
func (bh *BatchHeader) BatchNumberField() string <span class="cov8" title="1">{
        return bh.numericField(bh.BatchNumber, 7)
}</span>

func (bh *BatchHeader) settlementDateField() string <span class="cov8" title="1">{
        return bh.alphaField(bh.settlementDate, 3)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import "fmt"

// BatchPOP holds the BatchHeader and BatchControl and all EntryDetail for POP Entries.
//
// Point-of-Purchase. A check presented in-person to a merchant for purchase is presented
// as an ACH entry instead of a physical check.
//
// This ACH debit application is used by originators as a method of payment for the
// in-person purchase of goods or services by consumers. These Single Entry debit
// entries are initiated by the originator based on a written authorization and
// account information drawn from the source document (a check) obtained from the
// consumer at the point-of-purchase. The source document, which is voided by the
// merchant and returned to the consumer at the point-of-purchase, is used to
// collect the consumerâ€™s routing number, account number and check serial number that
// will be used to generate the debit entry to the consumerâ€™s account.
//
// The difference between POP and ARC is that ARC can result from a check mailed in whereas POP is in-person.
type BatchPOP struct {
        batch
}

// NewBatchPOP returns a *BatchPOP
func NewBatchPOP(bh *BatchHeader) *BatchPOP <span class="cov8" title="1">{
        batch := new(BatchPOP)
        batch.SetControl(NewBatchControl())
        batch.SetHeader(bh)
        return batch
}</span>

// Validate checks valid NACHA batch rules. Assumes properly parsed records.
func (batch *BatchPOP) Validate() error <span class="cov8" title="1">{
        // basic verification of the batch before we validate specific rules.
        if err := batch.verify(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Add configuration based validation for this type.

        // Batch POP cannot have an addenda record
        <span class="cov8" title="1">if err := batch.isAddendaCount(0); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Add type specific validation.
        <span class="cov8" title="1">if batch.Header.StandardEntryClassCode != "POP" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchSECType, batch.Header.StandardEntryClassCode, "POP")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "StandardEntryClassCode", Msg: msg}
        }</span>

        // POP detail entries can only be a debit, ServiceClassCode must allow debits
        <span class="cov8" title="1">switch batch.Header.ServiceClassCode </span>{
        case 200, 220, 280:<span class="cov8" title="1">
                msg := fmt.Sprintf(msgBatchServiceClassCode, batch.Header.ServiceClassCode, "POP")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "ServiceClassCode", Msg: msg}</span>
        }

        <span class="cov8" title="1">for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                // POP detail entries must be a debit
                if entry.CreditOrDebit() != "D" </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchTransactionCodeCredit, entry.TransactionCode)
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "TransactionCode", Msg: msg}
                }</span>

                // Amount must be 25,000 or less
                <span class="cov8" title="1">if entry.Amount &gt; 2500000 </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchAmount, "25,000", "POP")
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "Amount", Msg: msg}
                }</span>

                // CheckSerialNumber, Terminal City, Terminal State underlying IdentificationNumber, must be defined
                <span class="cov8" title="1">if entry.IdentificationNumber == "" </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchCheckSerialNumber, "POP")
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "CheckSerialNumber", Msg: msg}
                }</span>

        }
        <span class="cov8" title="1">return nil</span>
}

// Create takes Batch Header and Entries and builds a valid batch
func (batch *BatchPOP) Create() error <span class="cov8" title="1">{
        // generates sequence numbers and batch control
        if err := batch.build(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Additional steps specific to batch type
        // ...

        <span class="cov8" title="1">return batch.Validate()</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import "fmt"

// BatchPOS holds the BatchHeader and BatchControl and all EntryDetail for POS Entries.
//
// A POS Entry is a debit Entry initiated at an â€œelectronic terminalâ€ to a Consumer
// Account of the Receiver to pay an obligation incurred in a point- of-sale
// transaction, or to effect a point-of-sale terminal cash withdrawal.
//
// Point-of-Sale Entries (POS) are ACH debit entries typically initiated by the use
// of a merchant-issued plastic card to pay an obligation at the point-of-sale. Much
// like a financial institution issued debit card, the merchant- issued debit card is
// swiped at the point-of-sale and approved for use; however, the authorization only
// verifies the card is open, active and within the cardâ€™s limitsâ€”it does not verify
// the Receiverâ€™s account balance or debit the account at the time of the purchase.
// Settlement of the transaction moves from the card network to the ACH Network through
// the creation of a POS entry by the card issuer to debit the Receiverâ€™s account.
type BatchPOS struct {
        batch
}

var msgBatchPOSAddenda = "found and 1 Addenda02 is required for SEC code POS"
var msgBatchPOSAddendaType = "%T found where Addenda02 is required for SEC code POS"

// NewBatchPOS returns a *BatchPOS
func NewBatchPOS(bh *BatchHeader) *BatchPOS <span class="cov8" title="1">{
        batch := new(BatchPOS)
        batch.SetControl(NewBatchControl())
        batch.SetHeader(bh)
        return batch
}</span>

// Validate checks valid NACHA batch rules. Assumes properly parsed records.
func (batch *BatchPOS) Validate() error <span class="cov8" title="1">{
        // basic verification of the batch before we validate specific rules.
        if err := batch.verify(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Add configuration based validation for this type.

        // POS Addenda must be Addenda02
        <span class="cov8" title="1">if err := batch.isAddenda02(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Add type specific validation.
        <span class="cov8" title="1">if batch.Header.StandardEntryClassCode != "POS" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchSECType, batch.Header.StandardEntryClassCode, "POS")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "StandardEntryClassCode", Msg: msg}
        }</span>

        //ToDo;  Determine if this is needed
        /*        // POS detail entries can only be a debit, ServiceClassCode must allow debits
                switch batch.Header.ServiceClassCode {
                case 200, 220, 280:
                        msg := fmt.Sprintf(msgBatchServiceClassCode, batch.Header.ServiceClassCode, "POS")
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "ServiceClassCode", Msg: msg}
                }*/

        <span class="cov8" title="1">for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                // POS detail entries must be a debit
                if entry.CreditOrDebit() != "D" </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchTransactionCodeCredit, entry.TransactionCode)
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "TransactionCode", Msg: msg}
                }</span>
                //ToDo;  Additional validations
        }
        <span class="cov8" title="1">return nil</span>
}

// Create takes Batch Header and Entries and builds a valid batch
func (batch *BatchPOS) Create() error <span class="cov8" title="1">{
        // generates sequence numbers and batch control
        if err := batch.build(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Additional steps specific to batch type
        // ...

        <span class="cov8" title="1">return batch.Validate()</span>
}

// isAddenda02 verifies that a Addenda02 exists for each EntryDetail and is Validated
func (batch *BatchPOS) isAddenda02() error <span class="cov8" title="1">{
        for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                // Addenda type must be equal to 1
                if len(entry.Addendum) != 1 </span><span class="cov8" title="1">{
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "Addendum", Msg: msgBatchPOSAddenda}
                }</span>
                // Addenda type assertion must be Addenda02
                <span class="cov8" title="1">addenda02, ok := entry.Addendum[0].(*Addenda02)
                if !ok </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchPOSAddendaType, entry.Addendum[0])
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "Addendum", Msg: msg}
                }</span>
                // Addenda02 must be Validated
                <span class="cov8" title="1">if err := addenda02.Validate(); err != nil </span><span class="cov8" title="1">{
                        // convert the field error in to a batch error for a consistent api
                        if e, ok := err.(*FieldError); ok </span><span class="cov8" title="1">{
                                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: e.FieldName, Msg: e.Msg}
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

// BatchPPD holds the Batch Header and Batch Control and all Entry Records for PPD Entries
type BatchPPD struct {
        batch
}

// NewBatchPPD returns a *BatchPPD
func NewBatchPPD(bh *BatchHeader) *BatchPPD <span class="cov8" title="1">{
        batch := new(BatchPPD)
        batch.SetControl(NewBatchControl())
        batch.SetHeader(bh)
        return batch
}</span>

// Validate checks valid NACHA batch rules. Assumes properly parsed records.
func (batch *BatchPPD) Validate() error <span class="cov8" title="1">{
        // basic verification of the batch before we validate specific rules.
        if err := batch.verify(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Add configuration based validation for this type.

        // Batch can have one addenda per entry record
        <span class="cov8" title="1">if err := batch.isAddendaCount(1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := batch.isTypeCode("05"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Add type specific validation.
        // ...
        <span class="cov8" title="1">return nil</span>
}

// Create takes Batch Header and Entries and builds a valid batch
func (batch *BatchPPD) Create() error <span class="cov8" title="1">{
        // generates sequence numbers and batch control
        if err := batch.build(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Additional steps specific to batch type
        // ...

        <span class="cov8" title="1">return batch.Validate()</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import "fmt"

// BatchRCK holds the BatchHeader and BatchControl and all EntryDetail for RCK Entries.
//
// Represented Check Entries (RCK). A physical check that was presented but returned because of
// insufficient funds may be represented as an ACH entry.
type BatchRCK struct {
        batch
}

// NewBatchRCK returns a *BatchRCK
func NewBatchRCK(bh *BatchHeader) *BatchRCK <span class="cov8" title="1">{
        batch := new(BatchRCK)
        batch.SetControl(NewBatchControl())
        batch.SetHeader(bh)
        return batch
}</span>

// Validate checks valid NACHA batch rules. Assumes properly parsed records.
func (batch *BatchRCK) Validate() error <span class="cov8" title="1">{
        // basic verification of the batch before we validate specific rules.
        if err := batch.verify(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Batch RCK cannot have an addenda record
        <span class="cov8" title="1">if err := batch.isAddendaCount(0); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Add type specific validation.
        <span class="cov8" title="1">if batch.Header.StandardEntryClassCode != "RCK" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchSECType, batch.Header.StandardEntryClassCode, "RCK")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "StandardEntryClassCode", Msg: msg}
        }</span>

        // RCK detail entries can only be a debit, ServiceClassCode must allow debits
        <span class="cov8" title="1">switch batch.Header.ServiceClassCode </span>{
        case 200, 220, 280:<span class="cov8" title="1">
                msg := fmt.Sprintf(msgBatchServiceClassCode, batch.Header.ServiceClassCode, "RCK")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "ServiceClassCode", Msg: msg}</span>
        }

        // CompanyEntryDescription is required to be REDEPCHECK
        <span class="cov8" title="1">if batch.Header.CompanyEntryDescription != "REDEPCHECK" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchCompanyEntryDescription, batch.Header.CompanyEntryDescription, "RCK")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "CompanyEntryDescription", Msg: msg}
        }</span>

        <span class="cov8" title="1">for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                // RCK detail entries must be a debit
                if entry.CreditOrDebit() != "D" </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchTransactionCodeCredit, entry.TransactionCode)
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "TransactionCode", Msg: msg}
                }</span>

                // // Amount must be 2,500 or less
                <span class="cov8" title="1">if entry.Amount &gt; 250000 </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchAmount, "2,500", "RCK")
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "Amount", Msg: msg}
                }</span>

                // CheckSerialNumber underlying IdentificationNumber, must be defined
                <span class="cov8" title="1">if entry.IdentificationNumber == "" </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchCheckSerialNumber, "RCK")
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "CheckSerialNumber", Msg: msg}
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Create takes Batch Header and Entries and builds a valid batch
func (batch *BatchRCK) Create() error <span class="cov8" title="1">{
        // generates sequence numbers and batch control
        if err := batch.build(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Additional steps specific to batch type
        // ...

        <span class="cov8" title="1">return batch.Validate()</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import "fmt"

// BatchTEL is a batch that handles SEC payment type Telephone-Initiated Entries (TEL)
// Telephone-Initiated Entries (TEL) are consumer debit transactions. The NACHA Operating Rules permit TEL entries when the Originator obtains the Receiverâ€™s authorization for the debit entry orally via the telephone.
// An entry based upon a Receiverâ€™s oral authorization must utilize the TEL (Telephone-Initiated Entry) Standard Entry Class (SEC) Code.
type BatchTEL struct {
        batch
}

// NewBatchTEL returns a *BatchTEL
func NewBatchTEL(bh *BatchHeader) *BatchTEL <span class="cov8" title="1">{
        batch := new(BatchTEL)
        batch.SetControl(NewBatchControl())
        batch.SetHeader(bh)
        return batch
}</span>

// Validate ensures the batch meets NACHA rules specific to the SEC type TEL
func (batch *BatchTEL) Validate() error <span class="cov8" title="1">{
        // basic verification of the batch before we validate specific rules.
        if err := batch.verify(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Add configuration based validation for this type.
        // TEL can not have an addenda
        <span class="cov8" title="1">if err := batch.isAddendaCount(0); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Add type specific validation.
        <span class="cov8" title="1">if batch.Header.StandardEntryClassCode != "TEL" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchSECType, batch.Header.StandardEntryClassCode, "TEL")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "StandardEntryClassCode", Msg: msg}
        }</span>
        // can not have credits in TEL batches
        <span class="cov8" title="1">for _, entry := range batch.Entries </span><span class="cov8" title="1">{
                if entry.CreditOrDebit() != "D" </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(msgBatchTransactionCodeCredit, entry.IndividualName)
                        return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "TransactionCode", Msg: msg}
                }</span>
        }

        <span class="cov8" title="1">return batch.isPaymentTypeCode()</span>
}

// Create builds the batch sequence numbers and batch control. Additional creation
func (batch *BatchTEL) Create() error <span class="cov8" title="1">{
        // generates sequence numbers and batch control
        if err := batch.build(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return batch.Validate()</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package ach

import (
        "fmt"
)

// BatchWEB creates a batch file that handles SEC payment type WEB.
// Entry submitted pursuant to an authorization obtained solely via the Internet or a wireless network
// For consumer accounts only.
type BatchWEB struct {
        batch
}

var (
        msgBatchWebPaymentType = "%v is not a valid payment type S (single entry) or R (recurring)"
)

// NewBatchWEB returns a *BatchWEB
func NewBatchWEB(bh *BatchHeader) *BatchWEB <span class="cov8" title="1">{
        batch := new(BatchWEB)
        batch.SetControl(NewBatchControl())
        batch.SetHeader(bh)
        return batch
}</span>

// Validate ensures the batch meets NACHA rules specific to this batch type.
func (batch *BatchWEB) Validate() error <span class="cov8" title="1">{
        // basic verification of the batch before we validate specific rules.
        if err := batch.verify(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Add configuration based validation for this type.
        // Web can have up to one addenda per entry record
        <span class="cov8" title="1">if err := batch.isAddendaCount(1); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := batch.isTypeCode("05"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Add type specific validation.
        <span class="cov8" title="1">if batch.Header.StandardEntryClassCode != "WEB" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgBatchSECType, batch.Header.StandardEntryClassCode, "WEB")
                return &amp;BatchError{BatchNumber: batch.Header.BatchNumber, FieldName: "StandardEntryClassCode", Msg: msg}
        }</span>

        <span class="cov8" title="1">return batch.isPaymentTypeCode()</span>
}

// Create builds the batch sequence numbers and batch control. Additional creation
func (batch *BatchWEB) Create() error <span class="cov8" title="1">{
        // generates sequence numbers and batch control
        if err := batch.build(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return batch.Validate()</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "fmt"
)

// Batcher abstract the different ACH batch types that can exist in a file.
// Each batch type is defined by SEC (Standard Entry Class) code in the Batch Header
// * SEC identifies the payment type (product) found within an ACH batch-using a 3-character code
// * The SEC Code pertains to all items within batch
//    * Determines format of the entry detail records
//    * Determines addenda records (required or optional PLUS one or up to 9,999 records)
//    * Determines rules to follow (return time frames)
//           * Some SEC codes require specific data in predetermined fields within the ACH record
type Batcher interface {
        GetHeader() *BatchHeader
        SetHeader(*BatchHeader)
        GetControl() *BatchControl
        SetControl(*BatchControl)
        GetEntries() []*EntryDetail
        AddEntry(*EntryDetail)
        Create() error
        Validate() error
        // Category defines if a Forward or Return
        Category() string
}

// BatchError is an Error that describes batch validation issues
type BatchError struct {
        BatchNumber int
        FieldName   string
        Msg         string
}

func (e *BatchError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("BatchNumber %d %s %s", e.BatchNumber, e.FieldName, e.Msg)
}</span>

// Errors specific to parsing a Batch container
var (
        // generic messages
        msgBatchHeaderControlEquality     = "header %v is not equal to control %v"
        msgBatchCalculatedControlEquality = "calculated %v is out-of-balance with control %v"
        msgBatchAscending                 = "%v is less than last %v. Must be in ascending order"
        // specific messages for error
        msgBatchCompanyEntryDescription = "Company entry description %v is not valid for batch type %v"
        msgBatchOriginatorDNE           = "%v is not â€œ2â€ for DNE with entry transaction code of 23 or 33"
        msgBatchTraceNumberNotODFI      = "%v in header does not match entry trace number %v"
        msgBatchAddendaIndicator        = "is 0 but found addenda record(s)"
        msgBatchAddendaTraceNumber      = "%v does not match proceeding entry detail trace number %v"
        msgBatchEntries                 = "must have Entry Record(s) to be built"
        msgBatchAddendaCount            = "%v addendum found where %v is allowed for batch type %v"
        msgBatchTransactionCodeCredit   = "%v a credit is not allowed"
        msgBatchSECType                 = "header SEC type code %v for batch type %v"
        msgBatchTypeCode                = "%v found in addenda and expecting %v for batch type %v"
        msgBatchServiceClassCode        = "Service Class Code %v is not valid for batch type %v"
        msgBatchForwardReturn           = "Forward and Return entries found in the same batch"
        msgBatchAmount                  = "Amount must be less than %v for SEC code %v"
        msgBatchCheckSerialNumber       = "Check Serial Number is required for SEC code %v"
        msgBatchTransactionCode         = "Transaction code %v is not allowed for batch type %v"
)
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2017 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "strconv"
        "strings"
        "time"
)

// converters handles golang to ACH type Converters
type converters struct{}

func (c *converters) parseNumField(r string) (s int) <span class="cov8" title="1">{
        s, _ = strconv.Atoi(strings.TrimSpace(r))
        return s
}</span>

func (c *converters) parseStringField(r string) (s string) <span class="cov8" title="1">{
        s = strings.TrimSpace(r)
        return s
}</span>

// formatSimpleDate takes a time.Time and returns a string of YYMMDD
func (c *converters) formatSimpleDate(t time.Time) string <span class="cov8" title="1">{
        return t.Format("060102")
}</span>

// parseSimpleDate returns a time.Time when passed time as YYMMDD
func (c *converters) parseSimpleDate(s string) time.Time <span class="cov8" title="1">{
        t, _ := time.Parse("060102", s)
        return t
}</span>

// formatSimpleTime returns a string of HHMM when  passed a time.Time
func (c *converters) formatSimpleTime(t time.Time) string <span class="cov8" title="1">{
        return t.Format("1504")
}</span>

// parseSimpleTime returns a time.Time when passed a string of HHMM
func (c *converters) parseSimpleTime(s string) time.Time <span class="cov8" title="1">{
        t, _ := time.Parse("1504", s)
        return t
}</span>

// alphaField Alphanumeric and Alphabetic fields are left-justified and space filled.
func (c *converters) alphaField(s string, max uint) string <span class="cov8" title="1">{
        ln := uint(len(s))
        if ln &gt; max </span><span class="cov8" title="1">{
                return s[:max]
        }</span>
        <span class="cov8" title="1">s += strings.Repeat(" ", int(max-ln))
        return s</span>
}

// numericField right-justified, unisigned, and zero filled
func (c *converters) numericField(n int, max uint) string <span class="cov8" title="1">{
        s := strconv.Itoa(n)
        ln := uint(len(s))
        if ln &gt; max </span><span class="cov8" title="1">{
                return s[ln-max:]
        }</span>
        <span class="cov8" title="1">s = strings.Repeat("0", int(max-ln)) + s
        return s</span>
}

// stringRTNField slices to max length and zero filled
func (c *converters) stringRTNField(s string, max uint) string <span class="cov8" title="1">{
        ln := uint(len(s))
        if ln &gt; max </span><span class="cov8" title="1">{
                return s[:max]
        }</span>
        <span class="cov8" title="1">s = strings.Repeat("0", int(max-ln)) + s
        return s</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "fmt"
        "strconv"
        "strings"
)

// EntryDetail contains the actual transaction data for an individual entry.
// Fields include those designating the entry as a deposit (credit) or
// withdrawal (debit), the transit routing number for the entry recipientâ€™s financial
// institution, the account number (left justify,no zero fill), name, and dollar amount.
type EntryDetail struct {
        // ID is a client defined string used as a reference to this record.
        ID string `json:"id"`
        // RecordType defines the type of record in the block. 6
        recordType string
        // TransactionCode if the receivers account is:
        // Credit (deposit) to checking account â€˜22â€™
        // Prenote for credit to checking account â€˜23â€™
        // Debit (withdrawal) to checking account â€˜27â€™
        // Prenote for debit to checking account â€˜28â€™
        // Credit to savings account â€˜32â€™
        // Prenote for credit to savings account â€˜33â€™
        // Debit to savings account â€˜37â€™
        // Prenote for debit to savings account â€˜38â€™
        TransactionCode int `json:"transactionCode"`

        // RDFIIdentification is the RDFI's routing number without the last digit.
        // Receiving Depository Financial Institution
        RDFIIdentification string `json:"RDFIIdentification"`

        // CheckDigit the last digit of the RDFI's routing number
        CheckDigit string `json:"checkDigit"`

        // DFIAccountNumber is the receiver's bank account number you are crediting/debiting.
        // It important to note that this is an alphanumeric field, so its space padded, no zero padded
        DFIAccountNumber string `json:"DFIAccountNumber"`

        // Amount Number of cents you are debiting/crediting this account
        Amount int `json:"amount"`

        // IdentificationNumber an internal identification (alphanumeric) that
        // you use to uniquely identify this Entry Detail Record
        IdentificationNumber string `json:"identificationNumber,omitempty"`

        // IndividualName The name of the receiver, usually the name on the bank account
        IndividualName string `json:"individualName"`

        // DiscretionaryData allows ODFIs to include codes, of significance only to them,
        // to enable specialized handling of the entry. There will be no
        // standardized interpretation for the value of this field. It can either
        // be a single two-character code, or two distinct one-character codes,
        // according to the needs of the ODFI and/or Originator involved. This
        // field must be returned intact for any returned entry.
        //
        // WEB uses the Discretionary Data Field as the Payment Type Code
        DiscretionaryData string `json:"discretionaryData,omitempty"`

        // AddendaRecordIndicator indicates the existence of an Addenda Record.
        // A value of "1" indicates that one ore more addenda records follow,
        // and "0" means no such record is present.
        AddendaRecordIndicator int `json:"addendaRecordIndicator,omitempty"`

        // TraceNumber assigned by the ODFI in ascending sequence, is included in each
        // Entry Detail Record, Corporate Entry Detail Record, and addenda Record.
        // Trace Numbers uniquely identify each entry within a batch in an ACH input file.
        // In association with the Batch Number, transmission (File Creation) Date,
        // and File ID Modifier, the Trace Number uniquely identifies an entry within a given file.
        // For addenda Records, the Trace Number will be identical to the Trace Number
        // in the associated Entry Detail Record, since the Trace Number is associated
        // with an entry or item rather than a physical record.
        TraceNumber int `json:"traceNumber,omitempty"`

        // Addendum a list of Addenda for the Entry Detail
        Addendum []Addendumer `json:"addendum,omitempty"`
        // Category defines if the entry is a Forward, Return, or NOC
        Category string `json:"category,omitempty"`
        // validator is composed for data validation
        validator
        // converters is composed for ACH to golang Converters
        converters
}

const (
        // CategoryForward defines the entry as being sent to the receiving institution
        CategoryForward = "Forward"
        // CategoryReturn defines the entry as being a return of a forward entry back to the originating institution
        CategoryReturn = "Return"
        // CategoryNOC defines the entry as being a notification of change of a forward entry to the originating institution
        CategoryNOC = "NOC"
        // ReturnOrNoc is the description for the  following TransactionCode: 21, 31, 41, 51, 26, 36, 46, 56
        ReturnOrNoc = "RN"
)

// NewEntryDetail returns a new EntryDetail with default values for non exported fields
func NewEntryDetail() *EntryDetail <span class="cov8" title="1">{
        entry := &amp;EntryDetail{
                recordType: "6",
                Category:   CategoryForward,
        }
        return entry
}</span>

// Parse takes the input record string and parses the EntryDetail values
func (ed *EntryDetail) Parse(record string) <span class="cov8" title="1">{
        // 1-1 Always "6"
        ed.recordType = "6"
        // 2-3 is checking credit 22 debit 27 savings credit 32 debit 37
        ed.TransactionCode = ed.parseNumField(record[1:3])
        // 4-11 the RDFI's routing number without the last digit.
        ed.RDFIIdentification = ed.parseStringField(record[3:11])
        // 12-12 The last digit of the RDFI's routing number
        ed.CheckDigit = ed.parseStringField(record[11:12])
        // 13-29 The receiver's bank account number you are crediting/debiting
        ed.DFIAccountNumber = record[12:29]
        // 30-39 Number of cents you are debiting/crediting this account
        ed.Amount = ed.parseNumField(record[29:39])
        // 40-54 An internal identification (alphanumeric) that you use to uniquely identify this Entry Detail Record
        ed.IdentificationNumber = record[39:54]
        // 55-76 The name of the receiver, usually the name on the bank account
        ed.IndividualName = record[54:76]
        // 77-78 allows ODFIs to include codes of significance only to them
        // For WEB transaction this field is the PaymentType which is either R(reoccurring) or S(single)
        // normally blank
        ed.DiscretionaryData = record[76:78]
        // 79-79 1 if addenda exists 0 if it does not
        ed.AddendaRecordIndicator = ed.parseNumField(record[78:79])
        // 80-94 An internal identification (alphanumeric) that you use to uniquely identify
        // this Entry Detail Record This number should be unique to the transaction and will help identify the transaction in case of an inquiry
        ed.TraceNumber = ed.parseNumField(record[79:94])
}</span>

// String writes the EntryDetail struct to a 94 character string.
func (ed *EntryDetail) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v",
                ed.recordType,
                ed.TransactionCode,
                ed.RDFIIdentificationField(),
                ed.CheckDigit,
                ed.DFIAccountNumberField(),
                ed.AmountField(),
                ed.IdentificationNumberField(),
                ed.IndividualNameField(),
                ed.DiscretionaryDataField(),
                ed.AddendaRecordIndicator,
                ed.TraceNumberField())
}</span>

// Validate performs NACHA format rule checks on the record and returns an error if not Validated
// The first error encountered is returned and stops that parsing.
func (ed *EntryDetail) Validate() error <span class="cov8" title="1">{
        if err := ed.fieldInclusion(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if ed.recordType != "6" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgRecordType, 6)
                return &amp;FieldError{FieldName: "recordType", Value: ed.recordType, Msg: msg}
        }</span>
        <span class="cov8" title="1">if err := ed.isTransactionCode(ed.TransactionCode); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TransactionCode", Value: strconv.Itoa(ed.TransactionCode), Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if err := ed.isAlphanumeric(ed.DFIAccountNumber); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "DFIAccountNumber", Value: ed.DFIAccountNumber, Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if err := ed.isAlphanumeric(ed.IdentificationNumber); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "IdentificationNumber", Value: ed.IdentificationNumber, Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if err := ed.isAlphanumeric(ed.IndividualName); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "IndividualName", Value: ed.IndividualName, Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if err := ed.isAlphanumeric(ed.DiscretionaryData); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "DiscretionaryData", Value: ed.DiscretionaryData, Msg: err.Error()}
        }</span>

        <span class="cov8" title="1">calculated := ed.CalculateCheckDigit(ed.RDFIIdentificationField())

        edCheckDigit, err := strconv.Atoi(ed.CheckDigit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if calculated != edCheckDigit </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgValidCheckDigit, calculated)
                return &amp;FieldError{FieldName: "RDFIIdentification", Value: ed.CheckDigit, Msg: msg}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// fieldInclusion validate mandatory fields are not default values. If fields are
// invalid the ACH transfer will be returned.
func (ed *EntryDetail) fieldInclusion() error <span class="cov8" title="1">{
        if ed.recordType == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "recordType", Value: ed.recordType, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if ed.TransactionCode == 0 </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TransactionCode", Value: strconv.Itoa(ed.TransactionCode), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if ed.RDFIIdentification == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "RDFIIdentification", Value: ed.RDFIIdentificationField(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if ed.DFIAccountNumber == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "DFIAccountNumber", Value: ed.DFIAccountNumber, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if ed.IndividualName == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "IndividualName", Value: ed.IndividualName, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if ed.TraceNumber == 0 </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "TraceNumber", Value: ed.TraceNumberField(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AddAddenda appends an Addendumer to the EntryDetail
func (ed *EntryDetail) AddAddenda(addenda Addendumer) []Addendumer <span class="cov8" title="1">{
        ed.AddendaRecordIndicator = 1
        // checks to make sure that we only have either or, not both
        switch addenda.(type) </span>{
        case *Addenda99:<span class="cov8" title="1">
                ed.Category = CategoryReturn
                ed.Addendum = nil
                ed.Addendum = append(ed.Addendum, addenda)
                return ed.Addendum</span>
        case *Addenda98:<span class="cov8" title="1">
                ed.Category = CategoryNOC
                ed.Addendum = nil
                ed.Addendum = append(ed.Addendum, addenda)
                return ed.Addendum</span>
        case *Addenda02:<span class="cov8" title="1">
                ed.Category = CategoryForward
                ed.Addendum = nil
                ed.Addendum = append(ed.Addendum, addenda)
                return ed.Addendum</span>
        // default is current *Addenda05
        default:<span class="cov8" title="1">
                ed.Category = CategoryForward
                ed.Addendum = append(ed.Addendum, addenda)
                return ed.Addendum</span>
        }
}

// SetRDFI takes the 9 digit RDFI account number and separates it for RDFIIdentification and CheckDigit
func (ed *EntryDetail) SetRDFI(rdfi string) *EntryDetail <span class="cov8" title="1">{
        s := ed.stringRTNField(rdfi, 9)
        ed.RDFIIdentification = ed.parseStringField(s[:8])
        ed.CheckDigit = ed.parseStringField(s[8:9])
        return ed
}</span>

// SetTraceNumber takes first 8 digits of ODFI and concatenates a sequence number onto the TraceNumber
func (ed *EntryDetail) SetTraceNumber(ODFIIdentification string, seq int) <span class="cov8" title="1">{
        trace := ed.stringRTNField(ODFIIdentification, 8) + ed.numericField(seq, 7)
        ed.TraceNumber = ed.parseNumField(trace)
}</span>

// RDFIIdentificationField get the rdfiIdentification with zero padding
func (ed *EntryDetail) RDFIIdentificationField() string <span class="cov8" title="1">{
        return ed.stringRTNField(ed.RDFIIdentification, 8)
}</span>

// DFIAccountNumberField gets the DFIAccountNumber with space padding
func (ed *EntryDetail) DFIAccountNumberField() string <span class="cov8" title="1">{
        return ed.alphaField(ed.DFIAccountNumber, 17)
}</span>

// AmountField returns a zero padded string of amount
func (ed *EntryDetail) AmountField() string <span class="cov8" title="1">{
        return ed.numericField(ed.Amount, 10)
}</span>

// IdentificationNumberField returns a space padded string of IdentificationNumber
func (ed *EntryDetail) IdentificationNumberField() string <span class="cov8" title="1">{
        return ed.alphaField(ed.IdentificationNumber, 15)
}</span>

// CheckSerialNumberField is used in RCK, ARC, BOC files but returns
// a space padded string of the underlying IdentificationNumber field
func (ed *EntryDetail) CheckSerialNumberField() string <span class="cov8" title="1">{
        return ed.alphaField(ed.IdentificationNumber, 15)
}</span>

// SetCheckSerialNumber setter for RCK, ARC, BOC CheckSerialNumber
// which is underlying IdentificationNumber
func (ed *EntryDetail) SetCheckSerialNumber(s string) <span class="cov8" title="1">{
        ed.IdentificationNumber = s
}</span>

// SetPOPCheckSerialNumber setter for POP CheckSerialNumber
// which is characters 1-9 of underlying CheckSerialNumber \ IdentificationNumber
func (ed *EntryDetail) SetPOPCheckSerialNumber(s string) <span class="cov8" title="1">{
        ed.IdentificationNumber = ed.alphaField(s, 9)
}</span>

// SetPOPTerminalCity setter for POP Terminal City
// which is characters 10-13 of underlying CheckSerialNumber \ IdentificationNumber
func (ed *EntryDetail) SetPOPTerminalCity(s string) <span class="cov8" title="1">{
        ed.IdentificationNumber = ed.IdentificationNumber + ed.alphaField(s, 4)
}</span>

// SetPOPTerminalState setter for POP Terminal State
// which is characters 14-15 of underlying CheckSerialNumber \ IdentificationNumber
func (ed *EntryDetail) SetPOPTerminalState(s string) <span class="cov8" title="1">{
        ed.IdentificationNumber = ed.IdentificationNumber + ed.alphaField(s, 2)
}</span>

// POPCheckSerialNumberField is used in POP, characters 1-9 of underlying BatchPOP
// CheckSerialNumber / IdentificationNumber
func (ed *EntryDetail) POPCheckSerialNumberField() string <span class="cov8" title="1">{
        //return ed.alphaField(ed.IdentificationNumber, 9)
        return ed.parseStringField(ed.IdentificationNumber[0:9])
}</span>

// POPTerminalCityField is used in POP, characters 10-13 of underlying BatchPOP
// CheckSerialNumber / IdentificationNumber
func (ed *EntryDetail) POPTerminalCityField() string <span class="cov8" title="1">{
        //return ed.alphaField(ed.IdentificationNumber, 9)
        return ed.parseStringField(ed.IdentificationNumber[9:13])
}</span>

// POPTerminalStateField is used in POP, characters 14-15 of underlying BatchPOP
// CheckSerialNumber / IdentificationNumber
func (ed *EntryDetail) POPTerminalStateField() string <span class="cov8" title="1">{
        //return ed.alphaField(ed.IdentificationNumber, 9)
        return ed.parseStringField(ed.IdentificationNumber[13:15])
}</span>

// IndividualNameField returns a space padded string of IndividualName
func (ed *EntryDetail) IndividualNameField() string <span class="cov8" title="1">{
        return ed.alphaField(ed.IndividualName, 22)
}</span>

// ReceivingCompanyField is used in CCD files but returns the underlying IndividualName field
func (ed *EntryDetail) ReceivingCompanyField() string <span class="cov0" title="0">{
        return ed.IndividualNameField()
}</span>

// SetReceivingCompany setter for CCD ReceivingCompany which is underlying IndividualName
func (ed *EntryDetail) SetReceivingCompany(s string) <span class="cov8" title="1">{
        ed.IndividualName = s
}</span>

// DiscretionaryDataField returns a space padded string of DiscretionaryData
func (ed *EntryDetail) DiscretionaryDataField() string <span class="cov8" title="1">{
        return ed.alphaField(ed.DiscretionaryData, 2)
}</span>

// PaymentTypeField returns the DiscretionaryData field used in WEB batch files
func (ed *EntryDetail) PaymentTypeField() string <span class="cov8" title="1">{
        // because DiscretionaryData can be changed outside of PaymentType we reset the value for safety
        ed.SetPaymentType(ed.DiscretionaryData)
        return ed.DiscretionaryData
}</span>

// SetPaymentType as R (Recurring) all other values will result in S (single)
func (ed *EntryDetail) SetPaymentType(t string) <span class="cov8" title="1">{
        t = strings.ToUpper(strings.TrimSpace(t))
        if t == "R" </span><span class="cov0" title="0">{
                ed.DiscretionaryData = "R"
        }</span><span class="cov8" title="1"> else {
                ed.DiscretionaryData = "S"
        }</span>
}

// TraceNumberField returns a zero padded TraceNumber string
func (ed *EntryDetail) TraceNumberField() string <span class="cov8" title="1">{
        return ed.numericField(ed.TraceNumber, 15)
}</span>

// CreditOrDebit returns a "C" for credit or "D" for debit based on the entry TransactionCode
func (ed *EntryDetail) CreditOrDebit() string <span class="cov8" title="1">{
        tc := strconv.Itoa(ed.TransactionCode)
        // take the second number in the TransactionCode
        switch tc[1:2] </span>{
        case "1", "2", "3", "4":<span class="cov8" title="1">
                return "C"</span>
        case "5", "6", "7", "8", "9":<span class="cov8" title="1">
                return "D"</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// TransactionCodeDescription determines the transaction code description based on the second number
// in the TransactionCode
func (ed *EntryDetail) TransactionCodeDescription() string <span class="cov8" title="1">{
        tc := strconv.Itoa(ed.TransactionCode)
        // Take the second number in the TransactionCode
        switch tc[1:2] </span>{
        // Return or NOC
        case "1", "6":<span class="cov8" title="1">
                return ReturnOrNoc</span>
        default:</span><span class="cov8" title="1">
        }
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2017 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

// Package ach reads and writes (ACH) Automated Clearing House files. ACH is the
// primary method of electronic money movement through the United States.
//
// https://en.wikipedia.org/wiki/Automated_Clearing_House
package ach

import (
        "fmt"
        "strconv"
)

// First position of all Record Types. These codes are uniquely assigned to
// the first byte of each row in a file.
const (
        fileHeaderPos   = "1"
        batchHeaderPos  = "5"
        entryDetailPos  = "6"
        entryAddendaPos = "7"
        batchControlPos = "8"
        fileControlPos  = "9"

        // RecordLength character count of each line representing a letter in a file
        RecordLength = 94
)

// Errors strings specific to parsing a Batch container
var (
        msgFileCalculatedControlEquality = "calculated %v is out-of-balance with control %v"
        // specific messages
        msgRecordLength      = "must be 94 characters and found %d"
        msgFileBatchOutside  = "outside of current batch"
        msgFileBatchInside   = "inside of current batch"
        msgFileControl       = "none or more than one file control exists"
        msgFileHeader        = "none or more than one file headers exists"
        msgUnknownRecordType = "%s is an unknown record type"
        msgFileNoneSEC       = "%v SEC(standard entry class) is not implemented"
)

// FileError is an error describing issues validating a file
type FileError struct {
        FieldName string
        Value     string
        Msg       string
}

func (e *FileError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s %s", e.FieldName, e.Msg)
}</span>

// File contains the structures of a parsed ACH File.
type File struct {
        ID      string      `json:"id"`
        Header  FileHeader  `json:"fileHeader"`
        Batches []Batcher   `json:"batches"`
        Control FileControl `json:"fileControl"`

        // NotificationOfChange (Notification of change) is a slice of references to BatchCOR in file.Batches
        NotificationOfChange []*BatchCOR
        // ReturnEntries is a slice of references to file.Batches that contain return entires
        ReturnEntries []Batcher

        converters
}

// NewFile constructs a file template.
func NewFile() *File <span class="cov8" title="1">{
        return &amp;File{
                Header:  NewFileHeader(),
                Control: NewFileControl(),
        }
}</span>

// Create creates a valid file and requires that the FileHeader and at least one Batch
func (f *File) Create() error <span class="cov8" title="1">{
        // Requires a valid FileHeader to build FileControl
        if err := f.Header.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Requires at least one Batch in the new file.
        <span class="cov8" title="1">if len(f.Batches) &lt;= 0 </span><span class="cov8" title="1">{
                return &amp;FileError{FieldName: "Batches", Value: strconv.Itoa(len(f.Batches)), Msg: "must have []*Batches to be built"}
        }</span>
        // add 2 for FileHeader/control and reset if build was called twice do to error
        <span class="cov8" title="1">totalRecordsInFile := 2
        batchSeq := 1
        fileEntryAddendaCount := 0
        fileEntryHashSum := 0
        totalDebitAmount := 0
        totalCreditAmount := 0
        for i, batch := range f.Batches </span><span class="cov8" title="1">{
                // create ascending batch numbers
                f.Batches[i].GetHeader().BatchNumber = batchSeq
                f.Batches[i].GetControl().BatchNumber = batchSeq
                batchSeq++
                // sum file entry and addenda records. Assume batch.Create() batch properly calculated control
                fileEntryAddendaCount = fileEntryAddendaCount + batch.GetControl().EntryAddendaCount
                // add 2 for Batch header/control + entry added count
                totalRecordsInFile = totalRecordsInFile + 2 + batch.GetControl().EntryAddendaCount
                // sum hash from batch control. Assume Batch.Build properly calculated field.
                fileEntryHashSum = fileEntryHashSum + batch.GetControl().EntryHash
                totalDebitAmount = totalDebitAmount + batch.GetControl().TotalDebitEntryDollarAmount
                totalCreditAmount = totalCreditAmount + batch.GetControl().TotalCreditEntryDollarAmount

        }</span>
        // create FileControl from calculated values
        <span class="cov8" title="1">fc := NewFileControl()
        fc.BatchCount = batchSeq - 1
        // blocking factor of 10 is static default value in f.Header.blockingFactor.
        if (totalRecordsInFile % 10) != 0 </span><span class="cov8" title="1">{
                fc.BlockCount = totalRecordsInFile/10 + 1
        }</span><span class="cov8" title="1"> else {
                fc.BlockCount = totalRecordsInFile / 10
        }</span>
        <span class="cov8" title="1">fc.EntryAddendaCount = fileEntryAddendaCount
        fc.EntryHash = fileEntryHashSum
        fc.TotalDebitEntryDollarAmountInFile = totalDebitAmount
        fc.TotalCreditEntryDollarAmountInFile = totalCreditAmount
        f.Control = fc

        return nil</span>
}

// AddBatch appends a Batch to the ach.File
func (f *File) AddBatch(batch Batcher) []Batcher <span class="cov8" title="1">{
        switch batch.(type) </span>{
        case *BatchCOR:<span class="cov8" title="1">
                f.NotificationOfChange = append(f.NotificationOfChange, batch.(*BatchCOR))</span>
        }
        <span class="cov8" title="1">if batch.Category() == CategoryReturn </span><span class="cov8" title="1">{
                f.ReturnEntries = append(f.ReturnEntries, batch)
        }</span>
        <span class="cov8" title="1">f.Batches = append(f.Batches, batch)
        return f.Batches</span>
}

// SetHeader allows for header to be built.
func (f *File) SetHeader(h FileHeader) *File <span class="cov8" title="1">{
        f.Header = h
        return f
}</span>

// Validate NACHA rules on the entire batch before being added to a File
func (f *File) Validate() error <span class="cov8" title="1">{
        // The value of the Batch Count Field is equal to the number of Company/Batch/Header Records in the file.
        if f.Control.BatchCount != len(f.Batches) </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgFileCalculatedControlEquality, len(f.Batches), f.Control.BatchCount)
                return &amp;FileError{FieldName: "BatchCount", Value: strconv.Itoa(len(f.Batches)), Msg: msg}
        }</span>

        <span class="cov8" title="1">if err := f.isEntryAddendaCount(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := f.isFileAmount(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return f.isEntryHash()</span>
}

// isEntryAddenda is prepared by hashing the RDFIâ€™s 8-digit Routing Number in each entry.
//The Entry Hash provides a check against inadvertent alteration of data
func (f *File) isEntryAddendaCount() error <span class="cov8" title="1">{
        count := 0
        // we assume that each batch block has already validated the addenda count is accurate in batch control.
        for _, batch := range f.Batches </span><span class="cov8" title="1">{
                count += batch.GetControl().EntryAddendaCount
        }</span>
        <span class="cov8" title="1">if f.Control.EntryAddendaCount != count </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgFileCalculatedControlEquality, count, f.Control.EntryAddendaCount)
                return &amp;FileError{FieldName: "EntryAddendaCount", Value: f.Control.EntryAddendaCountField(), Msg: msg}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// isFileAmount tThe Total Debit and Credit Entry Dollar Amounts Fields contain accumulated
// Entry Detail debit and credit totals within the file
func (f *File) isFileAmount() error <span class="cov8" title="1">{
        debit := 0
        credit := 0
        for _, batch := range f.Batches </span><span class="cov8" title="1">{
                debit += batch.GetControl().TotalDebitEntryDollarAmount
                credit += batch.GetControl().TotalCreditEntryDollarAmount
        }</span>
        <span class="cov8" title="1">if f.Control.TotalDebitEntryDollarAmountInFile != debit </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgFileCalculatedControlEquality, debit, f.Control.TotalDebitEntryDollarAmountInFile)
                return &amp;FileError{FieldName: "TotalDebitEntryDollarAmountInFile", Value: f.Control.TotalDebitEntryDollarAmountInFileField(), Msg: msg}
        }</span>
        <span class="cov8" title="1">if f.Control.TotalCreditEntryDollarAmountInFile != credit </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgFileCalculatedControlEquality, credit, f.Control.TotalCreditEntryDollarAmountInFile)
                return &amp;FileError{FieldName: "TotalCreditEntryDollarAmountInFile", Value: f.Control.TotalCreditEntryDollarAmountInFileField(), Msg: msg}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// isEntryHash validates the hash by recalculating the result
func (f *File) isEntryHash() error <span class="cov8" title="1">{
        hashField := f.calculateEntryHash()
        if hashField != f.Control.EntryHashField() </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgFileCalculatedControlEquality, hashField, f.Control.EntryHashField())
                return &amp;FileError{FieldName: "EntryHash", Value: f.Control.EntryHashField(), Msg: msg}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// calculateEntryHash This field is prepared by hashing the 8-digit Routing Number in each batch.
// The Entry Hash provides a check against inadvertent alteration of data
func (f *File) calculateEntryHash() string <span class="cov8" title="1">{
        hash := 0
        for _, batch := range f.Batches </span><span class="cov8" title="1">{
                hash = hash + batch.GetControl().EntryHash
        }</span>
        <span class="cov8" title="1">return f.numericField(hash, 10)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import "fmt"

// FileControl record contains entry counts, dollar totals and hash
// totals accumulated from each batch control record in the file.
type FileControl struct {
        // ID is a client defined string used as a reference to this record.
        ID string `json:"id"`
        // RecordType defines the type of record in the block. fileControlPos 9
        recordType string

        // BatchCount total number of batches (i.e., â€˜5â€™ records) in the file
        BatchCount int `json:"batchCount"`

        // BlockCount total number of records in the file (include all headers and trailer) divided
        // by 10 (This number must be evenly divisible by 10. If not, additional records consisting of all 9â€™s are added to the file after the initial â€˜9â€™ record to fill out the block 10.)
        BlockCount int `json:"blockCount,omitempty"`

        // EntryAddendaCount total detail and addenda records in the file
        EntryAddendaCount int `json:"entryAddendaCount"`

        // EntryHash calculated in the same manner as the batch has total but includes total from entire file
        EntryHash int `json:"entryHash"`

        // TotalDebitEntryDollarAmountInFile contains accumulated Batch debit totals within the file.
        TotalDebitEntryDollarAmountInFile int `json:"totalDebit"`

        // TotalCreditEntryDollarAmountInFile contains accumulated Batch credit totals within the file.
        TotalCreditEntryDollarAmountInFile int `json:"totalCredit"`
        // Reserved should be blank.
        reserved string
        // validator is composed for data validation
        validator
        // converters is composed for ACH to golang Converters
        converters
}

// Parse takes the input record string and parses the FileControl values
func (fc *FileControl) Parse(record string) <span class="cov8" title="1">{
        // 1-1 Always "9"
        fc.recordType = "9"
        // 2-7 The total number of Batch Header Record in the file. For example: "000003
        fc.BatchCount = fc.parseNumField(record[1:7])
        // 8-13 e total number of blocks on the file, including the File Header and File Control records. One block is 10 lines, so it's effectively the number of lines in the file divided by 10.
        fc.BlockCount = fc.parseNumField(record[7:13])
        // 14-21 Total number of Entry Detail Record in the file
        fc.EntryAddendaCount = fc.parseNumField(record[13:21])
        // 22-31 Total of all positions 4-11 on each Entry Detail Record in the file. This is essentially the sum of all the RDFI routing numbers in the file.
        // If the sum exceeds 10 digits (because you have lots of Entry Detail Records), lop off the most significant digits of the sum until there are only 10
        fc.EntryHash = fc.parseNumField(record[21:31])
        // 32-43 Number of cents of debit entries within the file
        fc.TotalDebitEntryDollarAmountInFile = fc.parseNumField(record[31:43])
        // 44-55 Number of cents of credit entries within the file
        fc.TotalCreditEntryDollarAmountInFile = fc.parseNumField(record[43:55])
        // 56-94 Reserved Always blank (just fill with spaces)
        fc.reserved = "                                       "
}</span>

// NewFileControl returns a new FileControl with default values for none exported fields
func NewFileControl() FileControl <span class="cov8" title="1">{
        return FileControl{
                recordType: "9",
                reserved:   "                                       ",
        }
}</span>

// String writes the FileControl struct to a 94 character string.
func (fc *FileControl) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v%v%v%v%v%v%v%v",
                fc.recordType,
                fc.BatchCountField(),
                fc.BlockCountField(),
                fc.EntryAddendaCountField(),
                fc.EntryHashField(),
                fc.TotalDebitEntryDollarAmountInFileField(),
                fc.TotalCreditEntryDollarAmountInFileField(),
                fc.reserved,
        )
}</span>

// Validate performs NACHA format rule checks on the record and returns an error if not Validated
// The first error encountered is returned and stops that parsing.
func (fc *FileControl) Validate() error <span class="cov8" title="1">{
        if err := fc.fieldInclusion(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if fc.recordType != "9" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgRecordType, 9)
                return &amp;FieldError{FieldName: "recordType", Value: fc.recordType, Msg: msg}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// fieldInclusion validate mandatory fields are not default values. If fields are
// invalid the ACH transfer will be returned.
func (fc *FileControl) fieldInclusion() error <span class="cov8" title="1">{
        if fc.recordType == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "recordType", Value: fc.recordType, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if fc.BatchCount == 0 </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "BatchCount", Value: fc.BatchCountField(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if fc.BlockCount == 0 </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "BlockCount", Value: fc.BlockCountField(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if fc.EntryAddendaCount == 0 </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "EntryAddendaCount", Value: fc.EntryAddendaCountField(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if fc.EntryHash == 0 </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "EntryAddendaCount", Value: fc.EntryAddendaCountField(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BatchCountField gets a string of the batch count zero padded
func (fc *FileControl) BatchCountField() string <span class="cov8" title="1">{
        return fc.numericField(fc.BatchCount, 6)
}</span>

// BlockCountField gets a string of the block count zero padded
func (fc *FileControl) BlockCountField() string <span class="cov8" title="1">{
        return fc.numericField(fc.BlockCount, 6)
}</span>

// EntryAddendaCountField gets a string of entry addenda batch count zero padded
func (fc *FileControl) EntryAddendaCountField() string <span class="cov8" title="1">{
        return fc.numericField(fc.EntryAddendaCount, 8)
}</span>

// EntryHashField gets a string of entry hash zero padded
func (fc *FileControl) EntryHashField() string <span class="cov8" title="1">{
        return fc.numericField(fc.EntryHash, 10)
}</span>

// TotalDebitEntryDollarAmountInFileField get a zero padded Total debit Entry Amount
func (fc *FileControl) TotalDebitEntryDollarAmountInFileField() string <span class="cov8" title="1">{
        return fc.numericField(fc.TotalDebitEntryDollarAmountInFile, 12)
}</span>

// TotalCreditEntryDollarAmountInFileField get a zero padded Total credit Entry Amount
func (fc *FileControl) TotalCreditEntryDollarAmountInFileField() string <span class="cov8" title="1">{
        return fc.numericField(fc.TotalCreditEntryDollarAmountInFile, 12)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "fmt"
        "strings"
        "time"
)

// Errors specific to a File Header Record
var (
        msgRecordType     = "received expecting %d"
        msgRecordSize     = "is not 094"
        msgBlockingFactor = "is not 10"
        msgFormatCode     = "is not 1"
)

// FileHeader is a Record designating physical file characteristics and identify
// the origin (sending point) and destination (receiving point) of the entries
// contained in the file. The file header also includes creation date and time
// fields which can be used to uniquely identify a file.
type FileHeader struct {
        // ID is a client defined string used as a reference to this record.
        ID string `json:"id"`
        // RecordType defines the type of record in the block. headerPos
        recordType string
        // PriorityCode consists of the numerals 01
        priorityCode string
        // ImmediateDestination contains the Routing Number of the ACH Operator or receiving
        // point to which the file is being sent.  The ach file format specifies a 10 character
        // field  begins with a blank space in the first position, followed by the four digit
        // Federal Reserve Routing Symbol, the four digit ABA Institution Identifier, and the Check
        // Digit (bTTTTAAAAC).  ImmediateDestinationField() will append the blank space to the
        // routing number.
        ImmediateDestination string `json:"immediateDestination"`

        // ImmediateOrigin contains the Routing Number of the ACH Operator or sending
        // point that is sending the file. The ach file format specifies a 10 character field
        // which begins with a blank space in the first position, followed by the four digit
        // Federal Reserve Routing Symbol, the four digit ABA Institution Identifier, and the Check
        // Digit (bTTTTAAAAC).  ImmediateOriginField() will append the blank space to the routing
        // number.
        ImmediateOrigin string `json:"immediateOrigin"`

        // FileCreationDate is expressed in a "YYMMDD" format. The File Creation
        // Date is the date on which the file is prepared by an ODFI (ACH input files)
        // or the date (exchange date) on which a file is transmitted from ACH Operator
        // to ACH Operator, or from ACH Operator to RDFIs (ACH output files).
        FileCreationDate time.Time `json:"fileCreationDate"`

        // FileCreationTime is expressed ina n "HHMM" (24 hour clock) format.
        // The system time when the ACH file was created
        FileCreationTime time.Time `json:"fileCreationTime"`

        // This field should start at zero and increment by 1 (up to 9) and then go to
        // letters starting at A through Z for each subsequent file that is created for
        // a single system date. (34-34) 1 numeric 0-9 or uppercase alpha A-Z.
        // I have yet to see this ID not A
        FileIDModifier string `json:"fileIDModifier,omitempty"`

        // RecordSize indicates the number of characters contained in each
        // record. At this time, the value "094" must be used.
        recordSize string

        // BlockingFactor defines the number of physical records within a block
        // (a block is 940 characters). For all files moving between a DFI and an ACH
        // Operator (either way), the value "10" must be used. If the number of records
        // within the file is not a multiple of ten, the remainder of the block must
        // be nine-filled.
        blockingFactor string

        // FormatCode a code to allow for future format variations. As
        // currently defined, this field will contain a value of "1".
        formatCode string

        // ImmediateDestinationName us the name of the ACH or receiving point for which that
        // file is destined. Name corresponding to the ImmediateDestination
        ImmediateDestinationName string `json:"immediateDestinationName"`

        // ImmediateOriginName is the name of the ACH operator or sending point that is
        // sending the file. Name corresponding to the ImmediateOrigin
        ImmediateOriginName string `json:"immediateOriginName"`

        // ReferenceCode is reserved for information pertinent to the Originator.
        ReferenceCode string `json:"referenceCode,omitempty"`
        // validator is composed for data validation
        validator
        // converters is composed for ACH to GoLang Converters
        converters
}

// NewFileHeader returns a new FileHeader with default values for none exported fields
func NewFileHeader() FileHeader <span class="cov8" title="1">{
        fh := FileHeader{
                recordType:     "1",
                priorityCode:   "01",
                FileIDModifier: "A",
                recordSize:     "094",
                blockingFactor: "10",
                formatCode:     "1",
        }
        return fh
}</span>

// Parse takes the input record string and parses the FileHeader values
func (fh *FileHeader) Parse(record string) <span class="cov8" title="1">{
        // (character position 1-1) Always "1"
        fh.recordType = "1"
        // (2-3) Always "01"
        fh.priorityCode = "01"
        // (4-13) A blank space followed by your ODFI's routing number. For example: " 121140399"
        fh.ImmediateDestination = fh.parseStringField(record[3:13])
        // (14-23) A 10-digit number assigned to you by the ODFI once they approve you to originate ACH files through them
        fh.ImmediateOrigin = fh.parseStringField(record[13:23])
        // 24-29 Today's date in YYMMDD format
        // must be after todays date.
        fh.FileCreationDate = fh.parseSimpleDate(record[23:29])
        // 30-33 The current time in HHMM format
        fh.FileCreationTime = fh.parseSimpleTime(record[29:33])
        // 35-37 Always "A"
        fh.FileIDModifier = record[33:34]
        // 35-37 always "094"
        fh.recordSize = "094"
        //38-39 always "10"
        fh.blockingFactor = "10"
        //40 always "1"
        fh.formatCode = "1"
        //41-63 The name of the ODFI. example "SILICON VALLEY BANK    "
        fh.ImmediateDestinationName = strings.TrimSpace(record[40:63])
        //64-86 ACH operator or sending point that is sending the file
        fh.ImmediateOriginName = strings.TrimSpace(record[63:86])
        //97-94 Optional field that may be used to describe the ACH file for internal accounting purposes
        fh.ReferenceCode = strings.TrimSpace(record[86:94])
}</span>

// String writes the FileHeader struct to a 94 character string.
func (fh *FileHeader) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v",
                fh.recordType,
                fh.priorityCode,
                fh.ImmediateDestinationField(),
                fh.ImmediateOriginField(),
                fh.FileCreationDateField(),
                fh.FileCreationTimeField(),
                fh.FileIDModifier,
                fh.recordSize,
                fh.blockingFactor,
                fh.formatCode,
                fh.ImmediateDestinationNameField(),
                fh.ImmediateOriginNameField(),
                fh.ReferenceCodeField(),
        )

}</span>

// Validate performs NACHA format rule checks on the record and returns an error if not Validated
// The first error encountered is returned and stops the parsing.
func (fh *FileHeader) Validate() error <span class="cov8" title="1">{

        if err := fh.fieldInclusion(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if fh.recordType != "1" </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgRecordType, 1)
                return &amp;FieldError{FieldName: "recordType", Value: fh.recordType, Msg: msg}
        }</span>
        <span class="cov8" title="1">if err := fh.isUpperAlphanumeric(fh.FileIDModifier); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "FileIDModifier", Value: fh.FileIDModifier, Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if len(fh.FileIDModifier) != 1 </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(msgValidFieldLength, 1)
                return &amp;FieldError{FieldName: "FileIDModifier", Value: fh.FileIDModifier, Msg: msg}
        }</span>
        <span class="cov8" title="1">if fh.recordSize != "094" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "recordSize", Value: fh.recordSize, Msg: msgRecordSize}
        }</span>
        <span class="cov8" title="1">if fh.blockingFactor != "10" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "blockingFactor", Value: fh.blockingFactor, Msg: msgBlockingFactor}
        }</span>
        <span class="cov8" title="1">if fh.formatCode != "1" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "formatCode", Value: fh.formatCode, Msg: msgFormatCode}
        }</span>
        <span class="cov8" title="1">if err := fh.isAlphanumeric(fh.ImmediateDestinationName); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ImmediateDestinationName", Value: fh.ImmediateDestinationName, Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if fh.ImmediateOrigin == "000000000" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ImmediateOrigin", Value: fh.ImmediateOrigin, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if fh.ImmediateDestination == "000000000" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ImmediateDestination", Value: fh.ImmediateDestination, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if err := fh.isAlphanumeric(fh.ImmediateOriginName); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ImmediateOriginName", Value: fh.ImmediateOriginName, Msg: err.Error()}
        }</span>
        <span class="cov8" title="1">if err := fh.isAlphanumeric(fh.ReferenceCode); err != nil </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ReferenceCode", Value: fh.ReferenceCode, Msg: err.Error()}
        }</span>

        // todo: handle test cases for before date
        /*
                if fh.fileCreationDate.Before(time.Now()) {
                        return false, ErrFileCreationDate
                }
        */
        <span class="cov8" title="1">return nil</span>
}

// fieldInclusion validate mandatory fields are not default values. If fields are
// invalid the ACH transfer will be returned.
func (fh *FileHeader) fieldInclusion() error <span class="cov8" title="1">{
        if fh.recordType == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "recordType", Value: fh.recordType, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if fh.ImmediateDestination == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ImmediateDestination", Value: fh.ImmediateDestinationField(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if fh.ImmediateOrigin == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "ImmediateOrigin", Value: fh.ImmediateOriginField(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if fh.FileCreationDate.IsZero() </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "FileCreationDate", Value: fh.FileCreationDate.String(), Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if fh.FileIDModifier == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "FileIDModifier", Value: fh.FileIDModifier, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if fh.recordSize == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "recordSize", Value: fh.recordSize, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if fh.blockingFactor == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "blockingFactor", Value: fh.blockingFactor, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">if fh.formatCode == "" </span><span class="cov8" title="1">{
                return &amp;FieldError{FieldName: "formatCode", Value: fh.formatCode, Msg: msgFieldInclusion}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ImmediateDestinationField gets the immediate destination number with zero padding
func (fh *FileHeader) ImmediateDestinationField() string <span class="cov8" title="1">{
        return " " + fh.stringRTNField(fh.ImmediateDestination, 9)
}</span>

// ImmediateOriginField gets the immediate origin number with 0 padding
func (fh *FileHeader) ImmediateOriginField() string <span class="cov8" title="1">{
        return " " + fh.stringRTNField(fh.ImmediateOrigin, 9)
}</span>

// FileCreationDateField gets the file creation date in YYMMDD format
func (fh *FileHeader) FileCreationDateField() string <span class="cov8" title="1">{
        return fh.formatSimpleDate(fh.FileCreationDate)
}</span>

// FileCreationTimeField gets the file creation time in HHMM format
func (fh *FileHeader) FileCreationTimeField() string <span class="cov8" title="1">{
        return fh.formatSimpleTime(fh.FileCreationTime)
}</span>

// ImmediateDestinationNameField gets the ImmediateDestinationName field padded
func (fh *FileHeader) ImmediateDestinationNameField() string <span class="cov8" title="1">{
        return fh.alphaField(fh.ImmediateDestinationName, 23)
}</span>

// ImmediateOriginNameField gets the ImmImmediateOriginName field padded
func (fh *FileHeader) ImmediateOriginNameField() string <span class="cov8" title="1">{
        return fh.alphaField(fh.ImmediateOriginName, 23)
}</span>

// ReferenceCodeField gets the ReferenceCode field padded
func (fh *FileHeader) ReferenceCodeField() string <span class="cov8" title="1">{
        return fh.alphaField(fh.ReferenceCode, 8)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "bufio"
        "fmt"
        "io"
        "strconv"
)

// ParseError is returned for parsing reader errors.
// The first line is 1.
type ParseError struct {
        Line   int    // Line number where the error accurd
        Record string // Name of the record type being parsed
        Err    error  // The actual error
}

func (e *ParseError) Error() string <span class="cov8" title="1">{
        if e.Record == "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("line:%d %T %s", e.Line, e.Err, e.Err)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("line:%d record:%s %T %s", e.Line, e.Record, e.Err, e.Err)</span>
}

// Reader reads records from a ACH-encoded file.
type Reader struct {
        // r handles the IO.Reader sent to be parser.
        scanner *bufio.Scanner
        // file is ach.file model being built as r is parsed.
        File File
        // line is the current line being parsed from the input r
        line string
        // currentBatch is the current Batch entries being parsed
        currentBatch Batcher
        // line number of the file being parsed
        lineNum int
        // recordName holds the current record name being parsed.
        recordName string
}

// error creates a new ParseError based on err.
func (r *Reader) error(err error) error <span class="cov8" title="1">{
        return &amp;ParseError{
                Line:   r.lineNum,
                Record: r.recordName,
                Err:    err,
        }
}</span>

// addCurrentBatch creates the current batch type for the file being read. A successful
// current batch will be added to r.File once parsed.
func (r *Reader) addCurrentBatch(batch Batcher) <span class="cov8" title="1">{
        r.currentBatch = batch
}</span>

// NewReader returns a new ACH Reader that reads from r.
func NewReader(r io.Reader) *Reader <span class="cov8" title="1">{
        return &amp;Reader{
                scanner: bufio.NewScanner(r),
        }
}</span>

// Read reads each line of the ACH file and defines which parser to use based
// on the first character of each line. It also enforces ACH formating rules and returns
// the appropriate error if issues are found.
func (r *Reader) Read() (File, error) <span class="cov8" title="1">{
        r.lineNum = 0
        // read through the entire file
        for r.scanner.Scan() </span><span class="cov8" title="1">{
                line := r.scanner.Text()
                r.lineNum++
                lineLength := len(line)

                switch </span>{
                case r.lineNum == 1 &amp;&amp; lineLength &gt; RecordLength &amp;&amp; lineLength%RecordLength == 0:<span class="cov8" title="1">
                        if err := r.processFixedWidthFile(&amp;line); err != nil </span><span class="cov8" title="1">{
                                return r.File, err
                        }</span>
                case lineLength != RecordLength:<span class="cov8" title="1">
                        msg := fmt.Sprintf(msgRecordLength, lineLength)
                        err := &amp;FileError{FieldName: "RecordLength", Value: strconv.Itoa(lineLength), Msg: msg}
                        return r.File, r.error(err)</span>
                default:<span class="cov8" title="1">
                        r.line = line
                        if err := r.parseLine(); err != nil </span><span class="cov8" title="1">{
                                return r.File, err
                        }</span>
                }
        }
        <span class="cov8" title="1">if (FileHeader{}) == r.File.Header </span><span class="cov8" title="1">{
                // Their must be at least one File Header
                r.recordName = "FileHeader"
                return r.File, r.error(&amp;FileError{Msg: msgFileHeader})
        }</span>
        <span class="cov8" title="1">if (FileControl{}) == r.File.Control </span><span class="cov8" title="1">{
                // Their must be at least one File Control
                r.recordName = "FileControl"
                return r.File, r.error(&amp;FileError{Msg: msgFileControl})
        }</span>

        <span class="cov8" title="1">return r.File, nil</span>
}

func (r *Reader) processFixedWidthFile(line *string) error <span class="cov8" title="1">{
        // it should be safe to parse this byte by byte since ACH files are ascii only
        record := ""
        for i, c := range *line </span><span class="cov8" title="1">{
                record = record + string(c)
                if i &gt; 0 &amp;&amp; (i+1)%RecordLength == 0 </span><span class="cov8" title="1">{
                        r.line = record
                        if err := r.parseLine(); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">record = ""</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *Reader) parseLine() error <span class="cov8" title="1">{
        switch r.line[:1] </span>{
        case fileHeaderPos:<span class="cov8" title="1">
                if err := r.parseFileHeader(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        case batchHeaderPos:<span class="cov8" title="1">
                if err := r.parseBatchHeader(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        case entryDetailPos:<span class="cov8" title="1">
                if err := r.parseEntryDetail(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        case entryAddendaPos:<span class="cov8" title="1">
                if err := r.parseAddenda(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        case batchControlPos:<span class="cov8" title="1">
                if err := r.parseBatchControl(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := r.currentBatch.Validate(); err != nil </span><span class="cov8" title="1">{
                        r.recordName = "Batches"
                        return r.error(err)
                }</span>
                <span class="cov8" title="1">r.File.AddBatch(r.currentBatch)
                r.currentBatch = nil</span>
        case fileControlPos:<span class="cov8" title="1">
                if r.line[:2] == "99" </span><span class="cov8" title="1">{
                        // final blocking padding
                        break</span>
                }
                <span class="cov8" title="1">if err := r.parseFileControl(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        default:<span class="cov8" title="1">
                msg := fmt.Sprintf(msgUnknownRecordType, r.line[:1])
                return r.error(&amp;FileError{FieldName: "recordType", Value: r.line[:1], Msg: msg})</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// parseFileHeader takes the input record string and parses the FileHeaderRecord values
func (r *Reader) parseFileHeader() error <span class="cov8" title="1">{
        r.recordName = "FileHeader"
        if (FileHeader{}) != r.File.Header </span><span class="cov8" title="1">{
                // Their can only be one File Header per File exit
                r.error(&amp;FileError{Msg: msgFileHeader})
        }</span>
        <span class="cov8" title="1">r.File.Header.Parse(r.line)

        if err := r.File.Header.Validate(); err != nil </span><span class="cov8" title="1">{
                return r.error(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// parseBatchHeader takes the input record string and parses the FileHeaderRecord values
func (r *Reader) parseBatchHeader() error <span class="cov8" title="1">{
        r.recordName = "BatchHeader"
        if r.currentBatch != nil </span><span class="cov8" title="1">{
                // batch header inside of current batch
                return r.error(&amp;FileError{Msg: msgFileBatchInside})
        }</span>

        // Ensure we have a valid batch header before building a batch.
        <span class="cov8" title="1">bh := NewBatchHeader()
        bh.Parse(r.line)
        if err := bh.Validate(); err != nil </span><span class="cov8" title="1">{
                return r.error(err)
        }</span>

        // Passing SEC type into NewBatch creates a Batcher of SEC code type.
        <span class="cov8" title="1">batch, err := NewBatch(bh)
        if err != nil </span><span class="cov0" title="0">{
                return r.error(err)
        }</span>

        <span class="cov8" title="1">r.addCurrentBatch(batch)
        return nil</span>
}

// parseEntryDetail takes the input record string and parses the EntryDetailRecord values
func (r *Reader) parseEntryDetail() error <span class="cov8" title="1">{
        r.recordName = "EntryDetail"
        if r.currentBatch == nil </span><span class="cov8" title="1">{
                return r.error(&amp;FileError{Msg: msgFileBatchOutside})
        }</span>
        <span class="cov8" title="1">ed := new(EntryDetail)
        ed.Parse(r.line)
        if err := ed.Validate(); err != nil </span><span class="cov0" title="0">{
                return r.error(err)
        }</span>
        <span class="cov8" title="1">r.currentBatch.AddEntry(ed)
        return nil</span>
}

// parseAddendaRecord takes the input record string and create an Addenda Type appended to the last EntryDetail
func (r *Reader) parseAddenda() error <span class="cov8" title="1">{
        r.recordName = "Addenda"

        if r.currentBatch == nil </span><span class="cov8" title="1">{
                msg := fmt.Sprint(msgFileBatchOutside)
                return r.error(&amp;FileError{FieldName: "Addenda", Msg: msg})
        }</span>
        <span class="cov8" title="1">if len(r.currentBatch.GetEntries()) == 0 </span><span class="cov8" title="1">{
                return r.error(&amp;FileError{FieldName: "Addenda", Msg: msgFileBatchOutside})
        }</span>
        <span class="cov8" title="1">entryIndex := len(r.currentBatch.GetEntries()) - 1
        entry := r.currentBatch.GetEntries()[entryIndex]

        if entry.AddendaRecordIndicator == 1 </span><span class="cov8" title="1">{
                switch r.line[1:3] </span>{
                case "05":<span class="cov8" title="1">
                        addenda05 := NewAddenda05()
                        addenda05.Parse(r.line)
                        if err := addenda05.Validate(); err != nil </span><span class="cov8" title="1">{
                                return r.error(err)
                        }</span>
                        <span class="cov8" title="1">r.currentBatch.GetEntries()[entryIndex].AddAddenda(addenda05)</span>
                case "98":<span class="cov8" title="1">
                        addenda98 := NewAddenda98()
                        addenda98.Parse(r.line)
                        if err := addenda98.Validate(); err != nil </span><span class="cov0" title="0">{
                                return r.error(err)
                        }</span>
                        <span class="cov8" title="1">r.currentBatch.GetEntries()[entryIndex].AddAddenda(addenda98)</span>
                case "99":<span class="cov8" title="1">
                        addenda99 := NewAddenda99()
                        addenda99.Parse(r.line)
                        if err := addenda99.Validate(); err != nil </span><span class="cov0" title="0">{
                                return r.error(err)
                        }</span>
                        <span class="cov8" title="1">r.currentBatch.GetEntries()[entryIndex].AddAddenda(addenda99)</span>
                }
        }<span class="cov8" title="1"> else {
                msg := fmt.Sprint(msgBatchAddendaIndicator)
                return r.error(&amp;FileError{FieldName: "AddendaRecordIndicator", Msg: msg})
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// parseBatchControl takes the input record string and parses the BatchControlRecord values
func (r *Reader) parseBatchControl() error <span class="cov8" title="1">{
        r.recordName = "BatchControl"
        if r.currentBatch == nil </span><span class="cov8" title="1">{
                // batch Control without a current batch
                return r.error(&amp;FileError{Msg: msgFileBatchOutside})
        }</span>
        <span class="cov8" title="1">r.currentBatch.GetControl().Parse(r.line)
        if err := r.currentBatch.GetControl().Validate(); err != nil </span><span class="cov8" title="1">{
                return r.error(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// parseFileControl takes the input record string and parses the FileControlRecord values
func (r *Reader) parseFileControl() error <span class="cov8" title="1">{
        r.recordName = "FileControl"
        if (FileControl{}) != r.File.Control </span><span class="cov8" title="1">{
                // Can be only one file control per file
                return r.error(&amp;FileError{Msg: msgFileControl})
        }</span>
        <span class="cov8" title="1">r.File.Control.Parse(r.line)
        if err := r.File.Control.Validate(); err != nil </span><span class="cov8" title="1">{
                return r.error(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "errors"
        "fmt"
        "math"
        "regexp"
        "strconv"
)

var (
        upperAlphanumericRegex = regexp.MustCompile(`[^ A-Z0-9!"#$%&amp;'()*+,-.\\/:;&lt;&gt;=?@\[\]^_{}|~]+`)
        alphanumericRegex      = regexp.MustCompile(`[^ \w!"#$%&amp;'()*+,-.\\/:;&lt;&gt;=?@\[\]^_{}|~]+`)
)

// validator is common validation and formating of golang types to ach type strings
type validator struct{}

// FieldError is returned for errors at a field level in a record
type FieldError struct {
        FieldName string // field name where error happened
        Value     string // value that cause error
        Msg       string // context of the error.
}

// Error message is constructed
// FieldName Msg Value
// Example1: BatchCount $% has none alphanumeric characters
// Example2: BatchCount 5 is out-of-balance with file count 6
func (e *FieldError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s %s %s", e.FieldName, e.Value, e.Msg)
}</span>

// Errors specific to validation
var (
        msgAlphanumeric     = "has non alphanumeric characters"
        msgUpperAlpha       = "is not uppercase A-Z or 0-9"
        msgFieldInclusion   = "is a mandatory field and has a default value"
        msgValidFieldLength = "is not length %d"
        msgServiceClass     = "is an invalid Service Class Code"
        msgSECCode          = "is an invalid Standard Entry Class Code"
        msgOrigStatusCode   = "is an invalid Originator Status Code"
        msgAddendaTypeCode  = "is an invalid Addenda Type Code"
        msgTransactionCode  = "is an invalid Transaction Code"
        msgValidCheckDigit  = "does not match calculated check digit %d"
)

// iServiceClass returns true if a valid service class code of a batch is found
func (v *validator) isServiceClass(code int) error <span class="cov8" title="1">{
        switch code </span>{
        case
                // ACH Mixed Debits and Credits
                200,
                // ACH Credits Only
                220,
                // ACH Debits Only
                225,
                // ACH Automated Accounting Advices
                280:<span class="cov8" title="1">
                return nil</span>
        }
        <span class="cov8" title="1">return errors.New(msgServiceClass)</span>
}

// isSECCode returns true if a SEC Code of a Batch is found
func (v *validator) isSECCode(code string) error <span class="cov8" title="1">{
        switch code </span>{
        case
                "ACK", "ADV", "ARC", "ATX", "BOC", "CCD", "CIE", "COR", "CTX", "DNE", "ENR",
                "IAT", "MTE", "POS", "PPD", "POP", "RCK", "SHR", "TEL", "TRC", "TRX", "WEB", "XCK":<span class="cov8" title="1">
                return nil</span>
        }
        <span class="cov8" title="1">return errors.New(msgSECCode)</span>
}

// isTypeCode returns true if a valid type code of an Addendum is found
//
// The Addenda Type Code defines the specific interpretation and format for the addenda information contained in the Entry.
func (v *validator) isTypeCode(code string) error <span class="cov8" title="1">{
        switch code </span>{
        case
                // For POS, SHR or MTE Entries
                "02",
                // Addenda Record
                "08",
                // Notification of Change and Refused Notification of Change Entry
                "98",
                // Return, Dishonored Return and Contested Dishonored Return Entries
                "99",
                //  IAT forward Entries and IAT Returns
                "10", "11", "12", "13", "14", "15", "16", "17",
                // ACK, ATX, CCD, CIE, CTX, DNE, ENR, PPD, TRX and WEB Entries
                "05":<span class="cov8" title="1">
                return nil</span>
        }
        <span class="cov8" title="1">return errors.New(msgAddendaTypeCode)</span>
}

// isTransactionCode ensures TransactionCode of an Entry is valid
//
// The Tran Code is a two-digit code in positions 2 - 3 of the Entry Detail Record (6 Record) within an ACH File.
// The first digit of the Tran Code indicates the account type to which the entry will post, where the number:
//        "2"designates a Checking Account.
//        "3"designates a Savings Account.
//         "4"designates a General Ledger Account.
//         "5"designates Loan Account.
//The second digit of the Tran Code identifies the entry as:
//        an original forward entry, where the number:
//                "2"designates a credit. or
//                "7"designates a debit.
//        a return or NOC, where the number:
//                "1"designates the return/NOC of a credit, or
//                "6"designates a return/NOC of a debit.
//        a pre-note or non-monetary informational transaction, where the number:
//                "3"designates a credit, or
//                "8"designates a debit.
func (v *validator) isTransactionCode(code int) error <span class="cov8" title="1">{
        switch code </span>{
        // TransactionCode if the receivers account is:
        case
                // Demand Credit Records (for checking, NOW, and share draft accounts)

                // Automated Return or Notification of Change for original transaction code '22', '23, '24'
                21,
                // Credit (deposit) to checking account â€˜22â€™
                22,
                // Prenote for credit to checking account â€˜23â€™
                23,
                // Zero dollar with remittance data (CCD/CTX only)
                24,

                // Demand Debit Records (for checking, NOW, and share draft accounts)

                // Automated Return or Notification of Change for original transaction code 27, 28, or 29
                26,
                // Debit (withdrawal) to checking account â€˜27â€™
                27,
                // Prenote for debit to checking account â€˜28â€™
                28,
                // Zero dollar with remittance data (for CCD, CTX, and IAT Entries only)
                29,

                // Savings Account Credit Records

                // Return or Notification of Change for original transaction code 32, 33, or 34
                31,
                // Credit to savings account â€˜32â€™
                32,
                // Prenote for credit to savings account â€˜33â€™
                33,
                // Zero dollar with remittance data (for CCD, CTX, and IAT Entries only); Acknowledgment Entries (ACK and ATX Entries only)
                34,

                // Savings Account Debit Records

                // Automated Return or Notification of Change for original transaction code '37', '38', '39
                36,
                // Debit to savings account â€˜37â€™
                37,
                // Prenote for debit to savings account â€˜38â€™
                38,
                // Zero dollar with remittance data (CCD/CTX only)
                39,

                // Financial Institution General Ledger Credit Records

                //Return or Notification of Change for original transaction code 42, 43, or 44
                41,
                // General Ledger Credit
                42,
                // Prenotification of General Ledger Credit (non-dollar)
                43,
                // Zero dollar with remittance data (for CCD and CTX Entries only)
                44,

                // Financial Institution General Ledger Debit Records

                // Return or Notification of Change for original transaction code 47, 48, or 49
                46,
                //General Ledger Debit
                47,
                // Prenotification of General Ledger Debit (non-dollar)
                48,
                // Zero dollar with remittance data (for CCD and CTX only)
                49,

                // Loan Account Credit Records
                // Return or Notification of Change for original transaction code 52, 53, or 54
                51,
                // Loan Account Credit
                52,
                // Prenotification of Loan Account Credit (non-dollar)
                53,
                // Zero dollar with remittance data (for CCD and CTX Entries only)
                54,

                // Loan Account Debit Records (for Reversals Only)

                // Loan Account Debit (Reversals Only)
                55,
                // Return or Notification of Change for original transaction code 55
                56,

                // Accounting Records (for use in ADV Files only)
                // These transaction codes represent accounting Entries.

                // Credit for ACH debits originated
                81,
                //Debit for ACH credits originated
                82,
                // Credit for ACH credits received
                83,
                // Debit for ACH debits received
                84,
                // Credit for ACH credits in Rejected batches
                85,
                // Debit for ACH debits in Rejected batches
                86,
                // Summary credit for respondent ACH activity
                87,
                // Summary debit for respondent ACH activity
                88:<span class="cov8" title="1">
                return nil</span>
        }
        <span class="cov8" title="1">return errors.New(msgTransactionCode)</span>
}

// isOriginatorStatusCode ensures status code of a batch is valid
func (v *validator) isOriginatorStatusCode(code int) error <span class="cov8" title="1">{
        switch code </span>{
        case
                // ADV file - prepared by an ACH Operator
                0,
                //Originator is a financial institution
                1,
                // Originator is a Government Agency or other agency not subject to ACH Rules
                2:<span class="cov8" title="1">
                return nil</span>
        }
        <span class="cov8" title="1">return errors.New(msgOrigStatusCode)</span>
}

// isUpperAlphanumeric checks if string only contains ASCII alphanumeric upper case characters
func (v *validator) isUpperAlphanumeric(s string) error <span class="cov8" title="1">{
        if upperAlphanumericRegex.MatchString(s) </span><span class="cov8" title="1">{
                return errors.New(msgUpperAlpha)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// isAlphanumeric checks if a string only contains ASCII alphanumeric characters
func (v *validator) isAlphanumeric(s string) error <span class="cov8" title="1">{
        if alphanumericRegex.MatchString(s) </span><span class="cov8" title="1">{
                // ^[ A-Za-z0-9_@./#&amp;+-]*$/
                return errors.New(msgAlphanumeric)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CalculateCheckDigit returns a check digit for a routing number
// Multiply each digit in the Routing number by a weighting factor. The weighting factors for each digit are:
// Position: 1 2 3 4 5 6 7 8
// Weights : 3 7 1 3 7 1 3 7
// Add the results of the eight multiplications
// Subtract the sum from the next highest multiple of 10.
// The result is the Check Digit
func (v *validator) CalculateCheckDigit(routingNumber string) int <span class="cov8" title="1">{
        var routeIndex [8]string
        for i := 0; i &lt; 8; i++ </span><span class="cov8" title="1">{
                routeIndex[i] = string(routingNumber[i])
        }</span>
        <span class="cov8" title="1">n, _ := strconv.Atoi(routeIndex[0])
        sum := (n * 3)
        n, _ = strconv.Atoi(routeIndex[1])
        sum = sum + (n * 7)
        n, _ = strconv.Atoi(routeIndex[2])
        sum = sum + n // multiply by 1
        n, _ = strconv.Atoi(routeIndex[3])
        sum = sum + (n * 3)
        n, _ = strconv.Atoi(routeIndex[4])
        sum = sum + (n * 7)
        n, _ = strconv.Atoi(routeIndex[5])
        sum = sum + n // multiply by 1
        n, _ = strconv.Atoi(routeIndex[6])
        sum = sum + (n * 3)
        n, _ = strconv.Atoi(routeIndex[7])
        sum = sum + (n * 7)

        return v.roundUp10(sum) - sum</span>
}

// roundUp10 round number up to the next ten spot.
func (v *validator) roundUp10(n int) int <span class="cov8" title="1">{
        return int(math.Ceil(float64(n)/10.0)) * 10
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright 2018 The ACH Authors
// Use of this source code is governed by an Apache License
// license that can be found in the LICENSE file.

package ach

import (
        "bufio"
        "io"
        "strings"
)

// A Writer writes an ach.file to a NACHA encoded file.
//
// As returned by NewWriter, a Writer writes ach.file structs into
// NACHA formted files.
//
type Writer struct {
        w       *bufio.Writer
        lineNum int //current line being written
}

// NewWriter returns a new Writer that writes to w.
func NewWriter(w io.Writer) *Writer <span class="cov8" title="1">{
        return &amp;Writer{
                w: bufio.NewWriter(w),
        }
}</span>

// Writer writes a single ach.file record to w
func (w *Writer) Write(file *File) error <span class="cov8" title="1">{
        if err := file.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">w.lineNum = 0
        // Iterate over all records in the file
        if _, err := w.w.WriteString(file.Header.String() + "\n"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">w.lineNum++

        for _, batch := range file.Batches </span><span class="cov8" title="1">{
                if _, err := w.w.WriteString(batch.GetHeader().String() + "\n"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">w.lineNum++
                for _, entry := range batch.GetEntries() </span><span class="cov8" title="1">{
                        if _, err := w.w.WriteString(entry.String() + "\n"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">w.lineNum++
                        for _, addenda := range entry.Addendum </span><span class="cov8" title="1">{
                                if _, err := w.w.WriteString(addenda.String() + "\n"); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">w.lineNum++</span>
                        }
                }
                <span class="cov8" title="1">if _, err := w.w.WriteString(batch.GetControl().String() + "\n"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">w.lineNum++</span>
        }
        <span class="cov8" title="1">if _, err := w.w.WriteString(file.Control.String() + "\n"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">w.lineNum++

        // pad the final block
        for i := 0; i &lt; (10-(w.lineNum%10)) &amp;&amp; w.lineNum%10 != 0; i++ </span><span class="cov8" title="1">{
                if _, err := w.w.WriteString(strings.Repeat("9", 94) + "\n"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Flush writes any buffered data to the underlying io.Writer.
// To check if an error occurred during the Flush, call Error.
func (w *Writer) Flush() <span class="cov8" title="1">{
        w.w.Flush()
}</span>

// Error reports any error that has occurred during a previous Write or Flush.
func (w *Writer) Error() error <span class="cov0" title="0">{
        _, err := w.w.Write(nil)
        return err
}</span>

// WriteAll writes multiple ach.files to w using Write and then calls Flush.
func (w *Writer) WriteAll(files []*File) error <span class="cov8" title="1">{
        for _, file := range files </span><span class="cov8" title="1">{
                err := w.Write(file)
                // TODO if one of the files errors at a Writer struct flag to decide if
                // the other files should still be written
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return w.w.Flush()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
